## **Урок 5: Вступ до DOM: Властивості, методи та глобальний об’єкт `window`**

### **1. Зміст уроку**

#### **A. Вступ до DOM (Document Object Model — Об’єктна Модель Документа)**
- **Що таке DOM?**
  - Визначення та призначення.
  - Подання вебсторінки у вигляді деревовидної структури.
- **Доступ до елементів DOM:**
  - `document.getElementById()`.
  - `document.querySelector()` та `document.querySelectorAll()`.
- **Маніпулювання елементами DOM:**
  - Зміна вмісту (`innerText`, `innerHTML`).
  - Модифікація атрибутів (`setAttribute()`, `getAttribute()`).
  - Додавання і видалення класів (`classList.add()`, `classList.remove()`).
- **Обробка подій:**
  - Додавання слухачів подій (`addEventListener()`).
  - Поширені події (клік, введення, надсилання форми).


##### Що таке DOM?

**Визначення:**
Document Object Model (DOM) — це програмний інтерфейс, який представляє структуру HTML або XML-документа як дерево об’єктів. Кожен елемент, атрибут і фрагмент тексту стає об’єктом, що дозволяє розробникам програмно керувати структурою, стилем і вмістом сторінки.

**Ключові характеристики:**
- **Деревоподібна структура:** Документ представлений як ієрархія вузлів (node tree).
- **Інтерфейс для скриптів:** JavaScript може взаємодіяти з вузлами DOM, змінюючи відображення в браузері.
- **Динамічне оновлення:** Можливість змінювати елементи, атрибути й вміст без перезавантаження всієї сторінки.

**Застосування в автоматизації тестування:**
- Вибір елементів для перевірки їх наявності, атрибутів чи тексту.
- Імітація дій користувача (кліки, введення) на елементах DOM.
- Перевірка, що елементи з’являються або зникають після певних дій.


##### Обробка подій у DOM

**Визначення:**
Обробка подій — це процес виявлення і реагування на взаємодії користувача або події, ініційовані браузером (наприклад, кліки, натискання клавіш, відправлення форм, рух миші тощо).

**Ключові характеристики:**
- **Слухачі подій:** Функції, які виконуються у відповідь на певну подію.
- **Асинхронна поведінка:** Події відбуваються асинхронно, запускаються користувачем чи по таймеру.
- **Керування взаємодією:** Дозволяє розробникам і тестувальникам моделювати і перевіряти реакцію додатку на дії користувача.

**Застосування в автоматизації тестування:**
- Тестування взаємодії з UI, гарантія, що натискання кнопки викликає правильну поведінку.
- Перевірка логіки надсилання форм або обробки помилок.
- Підтвердження, що події введення з клавіатури викликають очікувані зміни на екрані.

#### **B. Властивості та методи DOM**

**Що таке властивості DOM-елементів?**  
Коли вебсторінка завантажується у браузері, він створює Document Object Model (DOM) — подання сторінки як дерево об’єктів. Кожен HTML-елемент стає DOM-об'єктом, що має властивості й методи, до яких ви можете звертатись і якими керувати через JavaScript.

- **Властивості DOM-елементів:**
  - `innerText`, `textContent`, `innerHTML`: Доступ або зміна тексту й HTML-вмісту елемента.
  - `value`: Для формових елементів, доступ/зміна введеного користувачем значення.
  - `style`: Доступ до inline CSS-властивостей.
  - `classList`: Додавання, видалення або перемикання CSS-класів без прямої зміни HTML-строки.
- **Поширені методи DOM:**
  - **Методи вибору:**
    - `document.getElementById('id')`: Вибір елемента за ID.
    - `document.querySelector('селектор')`: Вибір першого елемента за CSS-селектором.
    - `document.querySelectorAll('селектор')`: Вибір усіх елементів за CSS-селектором, повертає NodeList.
  - **Користувацькі атрибути:**
    - `data-*`: Користувацькі атрибути для зберігання додаткової інформації про елемент без впливу на його вигляд чи поведінку. Особливо корисні в JavaScript для додаткового контексту.
    - Data-атрибути дуже потужні в автоматизації тестування: додаючи data-cy, data-test або data-testid, ви створюєте стабільні селектори, стійкі до змін UI. Вони невидимі для користувача і не впливають на верстку. Тестові скрипти можуть надійно обирати елементи, наприклад, через cy.get('[data-test="login-button"]') у Cypress.

  - **Методи маніпуляції:**
    - `element.appendChild(node)`: Додає дочірній вузол до елемента.
    - `element.removeChild(node)`: Видаляє дочірній вузол.
    - `element.setAttribute('name', 'value')`: Встановлення або зміна атрибута.
    - `element.removeAttribute('name')`: Видаляє атрибут.
  - **Обробка подій (коротко):**
    - `element.addEventListener('подія', callback)`: Долучення обробників подій.
  - **Використання структур керування та даних:**
    - Цикли й умови для динамічного оновлення DOM (наприклад, перебір масиву для створення списку).
    - Об’єкти для зберігання селекторів чи посилань на DOM для повторного використання.
    - JSON-дані можуть бути отримані, щоб наповнювати елементи, динамічно оновлювати DOM.


1. **`innerText` / `textContent`:**
   - **Призначення:** Доступ чи зміна текстового вмісту елемента.
   - **Приклад:**
     ```javascript
     const heading = document.getElementById('main-title');
     console.log(heading.innerText); // Зчитує відображуваний текст заголовка
     heading.innerText = "Welcome to the Dashboard!";
     ```
   - **Різниця:** `innerText` враховує стиль і приховані елементи, `textContent` повертає весь текст, включаючи приховані та з переносами.

2. **`innerHTML`:**
   - **Призначення:** Доступ чи зміна HTML-розмітки всередині елемента.
   - **Приклад:**
     ```javascript
     const container = document.querySelector('#content');
     container.innerHTML = "<p>New paragraph!</p>"; // Вставляє HTML-код
     ```
   - **Увага:** Використання `innerHTML` з ненадійними даними може зробити сторінку вразливою до XSS (межсайтові скрипти).

3. **`value`:**
   - **Призначення:** Для елементів форм (input, textarea) — отримує або задає значення, введене користувачем.
   - **Приклад:**
     ```javascript
     const input = document.getElementById('username');
     input.value = "testUser";
     ```

4. **`classList`:**
   - **Призначення:** Керування CSS-класами елемента без прямого редагування атрибута `class`.
   - **Приклад:**
     ```javascript
     const button = document.querySelector('.btn');
     button.classList.add('active');
     button.classList.remove('disabled');
     button.classList.toggle('hidden');
     ```

5. **`style`:**
   - **Призначення:** Отримання чи зміна inline-стилів CSS елемента.
   - **Приклад:**
     ```javascript
     const box = document.querySelector('.box');
     box.style.backgroundColor = "blue";
     box.style.color = "white";
     ```
   - **Примітка:** Краще маніпулювати класами й використовувати зовнішній CSS для підтримки, ніж задавати стилі inline.

##### Доступ до DOM-елементів

**Вибір елементів:**
```html
<!-- index.html -->
<div id="container">
  <h1 class="title">Hello, World!</h1>
  <button id="clickMeBtn">Click Me</button>
</div>
```

```javascript
// JavaScript
const container = document.getElementById("container");
const title = document.querySelector(".title");
const button = document.querySelector("#clickMeBtn");
```

**Кращі практики:**
- Використовуйте `document.getElementById()` при виборі за ID для кращої продуктивності.
- Використовуйте `document.querySelector()` та `document.querySelectorAll()` для складних або гнучких селекторів.
- Давайте описові імена ID та класам, щоб селектори були зрозуміліші.

##### Маніпулювання DOM-елементами

**Зміна вмісту:**
```javascript
title.innerText = "Welcome to the Test Page!";
```

**Зміна атрибутів:**
```javascript
button.setAttribute("disabled", "true");
console.log(button.getAttribute("id")); // "clickMeBtn"
```

**Зміна класів:**
```javascript
title.classList.add("highlight");
title.classList.remove("old-class");
```

**Кращі практики:**
- Мінімізуйте пряме маніпулювання DOM, заздалегідь кешуючи посилання на елементи.
- Для зміни стилю використовуйте класи й CSS, а не inline-стилі.
- Групуйте та пакетно виконуйте операції з DOM для зменшення навантаження.

##### Обробка подій

**Додавання слухачів подій:**
```javascript
button.addEventListener("click", function () {
  console.log("Button was clicked!");
  container.innerHTML += "<p>Button Clicked!</p>";
});
```

**Кращі практики:**
- Використовуйте неінвазивну обробку подій (`addEventListener`), а не inline-атрибути `onclick`.
- Давайте функціям-обробникам описові імена:

```javascript
function handleButtonClick(event) {
  console.log("Button clicked:", event.target);
}

button.addEventListener("click", handleButtonClick);
```

- Видаляйте непотрібні слухачі подій для уникнення витоків пам’яті:

```javascript
button.removeEventListener("click", handleButtonClick);
```


#### **B. Глобальний об’єкт `window`**
**Визначення:**  
У веббраузерах об’єкт `window` є глобальним об’єктом, який представляє вікно браузера зі сторінкою. Всі глобальні змінні, функції і об’єкти стають властивостями `window`.

- **Що таке об’єкт `window`?**
  - `window` — це глобальний об’єкт у середовищі браузера.
  - Представляє вікно браузера й надає методи та властивості для керування ним.
- **Основні властивості та методи `window`:**
  - **Властивості:**
    - `window.document`: Поточний DOM сторінки.
    - `window.location`: Інформація про URL та навігацію.
    - `window.history`: Доступ до історії сесії браузера.
    - `window.localStorage` та `window.sessionStorage`: Зберігання/отримання даних у браузері.
  - **Методи:**
    - `window.alert('повідомлення')`: Показує модальне вікно.
    - `window.confirm('повідомлення')`: Показує підтвердження, повертає true/false.
    - `window.setTimeout(callback, milliseconds)`: Затримка виконання коду.
    - `window.setInterval(callback, milliseconds)`: Періодичне виконання коду.
  - **Неявна глобальна область видимості:**
    - Змінні, оголошені на верхньому рівні (без `let`, `const` чи старе `var`), можуть ставати властивостями `window` — цього краще уникати.
    - Розуміння області видимості (див. попередні уроки) допомагає уникнути "забруднення" глобального простору.


**Ключові моменти щодо `window`:**  
- **Глобальна область:** Глобальні змінні (без `let`, `const` чи `var`) можуть стати властивостями `window`. Сучасні кращі практики радять цього уникати.
- **Доступ до DOM та браузерних API:**  
  - `window.document` містить DOM поточної сторінки.
  - `window.location` надає інформацію та методи для роботи з URL.
  - `window.history` дозволяє керувати історією перегляду.
  - `window.alert()`, `window.confirm()`, `window.prompt()` виводять діалогові вікна.
  - `window.setTimeout()` і `window.setInterval()` — відкладене та періодичне виконання коду.

**Приклад:**
```javascript
console.log(window.location.href); // Виводить поточний URL
window.alert("Welcome to the site!");
```

**Краща практика:**  
Не зберігайте зайві дані у `window`. Тримайте змінні у межах функцій або модулів для унеможливлення засмічення глобального простору імен.

#### **D. Кращі практики роботи з DOM і `window`**
- **Підтримка коду:**
  - Зберігайте посилання на часто використовувані елементи у змінних.
  - Для посилань на DOM-елементи використовуйте описові імена змінних, уникайте "магічних рядків".
- **Продуктивність:**
  - Мінімізуйте зайві маніпуляції DOM — групуйте зміни, щоб зменшити кількість перерисовок.
  - Повторно використовуйте масиви, об’єкти та JSON для генерації чи оновлення DOM, а не "жорстко" прописуйте елементи.
- **Безпека й валідація даних:**
  - Не встановлюйте `innerHTML` ненадійними даними (ризик XSS).
  - Валідовуйте JSON і введені користувачем дані перед додаванням їх у DOM.
- **Використання структур керування:**
  - Застосовуйте цикли й умови для динамічного оновлення DOM на основі дій користувача чи отриманих з API даних.
  - Наприклад, якщо у вас масив продуктів у JSON, ви можете перебрати його для створення DOM-елементів кожного продукту.

#### **E. Практичні приклади**

1. **Доступ і оновлення вмісту елемента:**
   ```javascript
   const title = document.getElementById('page-title');
   title.innerText = "Welcome to the Dashboard!";
   ```

2. **Зміна атрибутів і класів елемента:**
   ```javascript
   const loginButton = document.querySelector('#login-btn');
   loginButton.setAttribute('disabled', 'true');

   const mainHeader = document.querySelector('h1');
   mainHeader.classList.add('highlighted');
   mainHeader.classList.remove('old-class');
   ```

3. **Динамічне створення та додавання елементів:**
   ```javascript
   const userList = document.getElementById('user-list');
   const users = [
     { name: "Alice", role: "admin" },
     { name: "Bob", role: "user" },
     { name: "Charlie", role: "moderator" }
   ];

   users.forEach(user => {
     const li = document.createElement('li');
     li.innerText = `${user.name} (${user.role})`;
     userList.appendChild(li);
   });
   ```

4. **Отримання JSON-даних та оновлення DOM:**

**Що таке `fetch()`?**  
`fetch()` — це вбудована функція JavaScript (частина Fetch API), яка дозволяє робити мережеві запити, наприклад, отримувати дані з URL. Вона повертає Promise, що спрощує обробку асинхронних операцій.

   ```javascript
   fetch('users.json')
     .then(response => response.json())
     .then(data => {
       const userContainer = document.querySelector('#user-container');
       data.forEach(user => {
         const div = document.createElement('div');
         div.innerText = `${user.name} - ${user.email}`;
         userContainer.appendChild(div);
       });
     });
   ```


  5. **setTimeout**
  **Що таке `setTimeout()`?**  
`setTimeout()` — це функція браузера (через `window`), яка дозволяє виконати вказану функцію через певну затримку (у мілісекундах).

**Синтаксис:**
```javascript
window.setTimeout(() => {
  console.log("This message appears after 2 seconds");
}, 2000);
```

**Параметри:**
1. **Функція зворотного виклику (Callback):** Функція, яку потрібно виконати після затримки.
2. **Затримка (у мс):** Час, через який запускається callback. 1000 мс = 1 сек.

**Поведінка:**
- Callback не виконується, поки не мине затримка.
- Код не блокується; callback планується, а скрипт продовжує виконання. Після завершення часу викликається функція.

**Застосування в автоматизації тестування:**
- **Імітація очікування користувача:** Наприклад, тестування поведінки інтерфейсу після затримки (зникнення спінера завантаження).
- **Планування асинхронних перевірок:** Запуск коду після затримки для перевірки стану DOM.

**Зупинка тайм-ауту:**
- Ви можете зберегти результат `setTimeout()` у змінній і скасувати таймаут за допомогою `clearTimeout()`.
  ```javascript
  const timeoutId = setTimeout(() => {
    console.log("Will this message appear?");
  }, 5000);

  // Скасувати таймаут до спрацювання
  clearTimeout(timeoutId);
  ```

**Важливість JSON в автоматизації тестів:**  
JSON (JavaScript Object Notation) — це легкий формат для зберігання та обміну даними, який легко читається як людьми, так і машинами. Є незалежним від мови та широко використовується для взаємодії клієнта та сервера. В автоматизації тестування:

1. **Фікстури і тестові дані:**  
   Ви можете зберігати вхідні та очікувані значення у JSON. Це відокремлює дані від логіки тесту, спрощує оновлення, підтримку й повторне використання.

2. **Тестування API:**  
   Під час тестування застосунків, що взаємодіють із сервером, у відповідь часто надходить JSON. Парсинг та перевірка відповідей виконується просто.

3. **Макетування відповідей:**  
   У автоматизованих тестах ви можете подавати попередньо визначені дані як макетовані відповіді. Це гарантує детермінованість тестів без залежності від зовнішніх сервісів.

**Розбір і обробка JSON:**
- **Метод `response.json()`:**  
  Після виклику `fetch()` ви часто конвертуєте raw-відповідь у JSON-об’єкт:
  ```javascript
  fetch('users.json')
    .then(response => response.json()) // розбір JSON із відповіді
    .then(data => {
      console.log(data);
      // дані — це JS-об’єкт/масив: можна перебирати, перевіряти або змінювати
    });
  ```

#### Що таке `then` у функції `fetch()`?

**Пояснення:**
`then()` — це метод, доступний у Promise. Виклик `fetch()` повертає Promise. Метод `then()` визначає, що повинно відбутись при успішному виконанні (resolve) асинхронної операції.

- **Перший `.then()`:** Зазвичай використовується для обробки raw-відповіді та перетворення її у потрібний формат (наприклад, JSON).
- **Другий `.then()`:** Після отримання даних ви можете обробити їх: наприклад, оновити DOM, виконати перевірки тощо.

**Приклад:**
```javascript
fetch('users.json')
  .then(response => response.json())    // Конвертує тіло відповіді у JSON
  .then(data => {
    console.log(data);                  // Використовуйте розібрані дані тут
  })
  .catch(error => console.error(error));
```

**Ключовий момент:**  
- **`then()`** — спосіб ланцюжити асинхронні операції. Кожен `then()` повертає новий Promise і можна продовжувати ланцюг.
- **`catch()`** використовується для обробки помилок у ланцюжку.


5. **Використання об’єкта `window`:**
   ```javascript
   console.log(window.location.href); // URL поточної сторінки
   window.setTimeout(() => {
     alert("Time’s up!");
   }, 2000);
   ```

#### **F. Зв’язок із попередніми уроками**
- **Масиви та об’єкти:**
  - Використовуйте масиви для зберігання списків і створення DOM-елементів динамічно.
  - Зберігайте селектори або посилання на DOM в об’єктах для полегшення маніпуляцій.
- **JSON та робота з API:**
  - Завантажуйте JSON-дані для заповнення елементів на сторінці.
- **Структури керування:**
  - Використовуйте `if/else`, цикли та логічні умови для визначення, як і коли оновлювати DOM, обробляти введення, чи змінювати властивості `window`.
- **Поєднання понять:**
  - Все вивчене — змінні, функції, масиви, об’єкти, JSON, маніпулювання DOM, обробка подій — тепер можна інтегрувати для створення інтерактивних вебзастосунків.

---

### **2. Практична частина: вправи й пропозиції щодо функціоналу**

#### **A. Вправа: Взаємодія з DOM у тестах**
- **Завдання:**
  - Створіть HTML-сторінку з різними елементами: кнопки, поля вводу, контейнери.
  - Напишіть тести Cypress, які:
    - Вибирають і взаємодіють з DOM-елементами через селектори.
    - Перевіряють наявність і вміст елементів.
    - Імітують дії користувача: кліки, надсилання форм.
  - **Приклад:**
    ```html
    <!-- index.html -->
    <!DOCTYPE html>
    <html>
    <head>
      <title>DOM Interaction Test</title>
    </head>
    <body>
      <h1 id="title">Welcome to the Test Page</h1>
      <button id="changeTitle">Change Title</button>
      <input type="text" id="username" placeholder="Enter username" />
      <button id="submitForm">Submit</button>
      <div id="output"></div>

      <script>
        document.getElementById('changeTitle').addEventListener('click', () => {
          document.getElementById('title').innerText = 'Title Changed!';
        });

        document.getElementById('submitForm').addEventListener('click', () => {
          const username = document.getElementById('username').value;
          document.getElementById('output').innerText = `Hello, ${username}!`;
        });
      </script>
    </body>
    </html>
    ```

    ```javascript
    // Cypress Test
    describe('DOM Interaction Test', () => {
      beforeEach(() => {
        cy.visit('/index.html');
      });

      it('Changes the title when button is clicked', () => {
        cy.get('#changeTitle').click();
        cy.get('#title').should('have.text', 'Title Changed!');
      });

      it('Submits the form and displays greeting', () => {
        cy.get('#username').type('TestUser');
        cy.get('#submitForm').click();
        cy.get('#output').should('have.text', 'Hello, TestUser!');
      });
    });
    ```

- **Пропозиція до функціоналу:**
  - Розробіть динамічну сторінку, де можна:
    - Змінювати заголовок через кнопку.
    - Надсилати форму, щоб отримати персоналізоване вітання.
  - Напишіть Cypress-тести для автоматизації й перевірки цих взаємодій.


#### **B. Вправа: Оновлення контенту DOM**
- **Завдання:**
  - Створіть просту вебсторінку з заголовком, абзацом і кнопкою.
  - Напишіть JS-код для:
    - Зміни тексту заголовка через `innerText` при завантаженні сторінки.
    - Оновлення тексту абзацу при натисканні кнопки.
  - **Пропозиція до функціоналу:**
    - Сторінка "Welcome", яка спочатку показує загальне повідомлення, і персоналізує привітання після натискання кнопки.

#### **C. Вправа: Динамічне створення списку з JSON**
- **Завдання:**
  - Створіть JSON-файл (`products.json`) з масивом товарів (`name`, `price`, `category`).
  - Використайте `fetch()` для завантаження даних.
  - Динамічно створіть список товарів, показуючи назву й ціну кожного.
  - **Пропозиція до функціоналу:**
    - Сторінка з переліком товарів, яка підтягує дані та відображає у таблиці чи списку, оновлюючи контент при зміні даних.

#### **D. Вправа: Використання методів `window`**
- **Завдання:**
  - Показати alert через 2 секунди з використанням `window.setTimeout()`.
  - Вивести URL поточної сторінки через `window.location.href`.
  - Додати кнопку “Оновити”, яка використовує `window.location.reload()` для перезавантаження.
  - **Пропозиція до функціоналу:**
    - Сторінка зі сповіщенням і кнопкою для перезавантаження, демонструючи маніпуляції через `window`.

---

### **3. Можливі питання студентів**

1. **Яка різниця між `document.getElementById()` і `document.querySelector()`?**
   - **Відповідь:**  
     `document.getElementById()` вибирає елемент за унікальним ID і працює швидше. `document.querySelector()` дозволяє вибирати елементи за CSS-селектором, що дає більше гнучкості.

2. **Як змінити вміст DOM-елемента через JavaScript?**
   - **Відповідь:**  
     Ви можете змінити вміст через властивості `innerText`, `innerHTML` або `textContent`. Наприклад:
     ```javascript
     document.getElementById('title').innerText = 'New Title';
     ```

3. **Коли використовувати `innerText`, а коли `innerHTML`?**  
   **Відповідь:**  
   - `innerText` зчитує/встановлює текст без HTML-тегів.
   - `innerHTML` дозволяє прямо змінювати HTML-код усередині елемента. Використовуйте обережно через ризик XSS.

4. **Як уникати забруднення глобальної області через об’єкт `window`?**  
   **Відповідь:**  
   - Завжди оголошуйте змінні через `let` або `const` у функціях чи блоках.
   - Використовуйте модулі чи замикання для ізоляції змінних.
   - Не додавайте невиправданих даних у `window`, зберігайте їх у об’єктах чи модулях.

5. **Яка різниця між `document.getElementById()` і `document.querySelector()`?**  
   **Відповідь:**  
   - `getElementById()` вибирає по ID, повертає один елемент.
   - `querySelector()` використовує CSS-селектори, повертає перший знайдений елемент.
   - `querySelector()` більш гнучкий, але `getElementById()` працює швидше для ID.

6. **Чи можна ітерувати DOM-колекції як масиви?**  
   **Відповідь:**  
   - `querySelectorAll()` повертає NodeList, по якій можна пройтись `forEach()`.
   - Також, NodeList або HTMLCollection можна перетворити в масив через `Array.from()` і тоді використовувати методи масивів.

---

### **4. Додаткові матеріали: рекомендації**

#### **A. Офіційна документація та гіди:**
- [MDN Web Docs - Вступ до DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction)
- [MDN Web Docs - Об’єкт Window](https://developer.mozilla.org/en-US/docs/Web/API/Window)
- [MDN Web Docs - Маніпуляція DOM](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents)

#### **B. Туторіали та статті:**
- **W3Schools DOM Tutorial:** [https://www.w3schools.com/js/js_htmldom.asp](https://www.w3schools.com/js/js_htmldom.asp)
- **JavaScript.info DOM Tutorial:** [https://javascript.info/document](https://javascript.info/document)

#### **C. Інтерактивні платформи навчання:**
- **FreeCodeCamp:** Вправи з маніпуляцій DOM та обробки подій.
- **Codecademy:** Інтерактивні уроки з роботи з DOM.

#### **D. Відеоуроки:**
- **Traversy Media на YouTube:** Відео по основах маніпулювання DOM.
- **The Net Ninja:** Туторіали по DOM, властивостям, методам та використанню об’єкта `window`.

#### **E. Платформи для практики:**
- Створюйте демо-сторінки для експериментів із різними методами DOM.
- Використовуйте JSON-файли як джерела даних для динамічного рендерингу UI.

#### **F. Спільнота та підтримка:**
- **Stack Overflow** та **Reddit** (`r/javascript`): Чудові ресурси для питань щодо DOM.
- **Discord-спільноти:** Приєднуйтесь до JavaScript або front-end каналів для обговорення питань DOM.

---

### **5. Пропонований розподіл уроку на 3 години**

#### **1 година: Властивості й методи DOM (60 хвилин)**
- **Огляд концепцій DOM (10 хв):**
  - Огляд структури DOM і того, як її бачить JavaScript.
- **DOM-властивості та методи (40 хв):**
  - `innerText`, `innerHTML`, `textContent`.
  - `classList` і `style`.
  - Створення, зміна й видалення елементів.
- **Коротке Q&A (10 хв):**
  - Відповіді на питання.

#### **2 година: Глобальний об’єкт Window та інтеграції (60 хвилин)**
- **Дослідження `window` (20 хв):**
  - `window.document`, `window.location`, `window.history`.
  - Дії з таймером (`setTimeout`, `setInterval`).
- **Практична інтеграція з даними (20 хв):**
  - Завантаження JSON-даних і оновлення DOM.
  - Використання циклів і умов для вирішення, що виводити.
- **Коротке Q&A (10 хв):**
  - Вирішення питань.
- **Перерва (10 хв):**
  - Короткий перепочинок.

#### **3 година: Практичні вправи й кращі практики (60 хвилин)**
- **Практика (40 хв):**
  - Оновлення тексту й атрибутів.
  - Створення списків із масивів чи JSON.
  - Використання методів `window` для сповіщень чи перезавантаження сторінки.
- **Огляд і питання (20 хв):**
  - Повторення ключових понять.
  - Заохочення до експериментів і складніших маніпуляцій DOM.

---

### **6. Додаткові рекомендації**

#### **A. Інтерактивні демонстрації:**
- Показувати live-кодинг:
  - Отримання JSON і виведення на сторінку.
  - Оновлення класів елементів при кліках.
  - Показ timed alert через `setTimeout()`.

#### **B. Візуальні засоби:**
- Схеми для пояснення дерева DOM.
- Діаграми-потоки для показу руху даних від JSON до DOM.
- Виділіть, як об’єкт `window` є найвищим рівнем у браузері.

#### **C. Заохочення до участі:**
- Запропонуйте студентам знайти й вивести `window.location.href`.
- Нехай студенти створюють і видаляють елементи на ходу.
- Дайте їм спробувати різні способи вибору елементів і властивостей.

#### **D. Чіткі інструкції:**
- Покрокові міні-завдання, наприклад, “Змінити текст заголовка і додати новий абзац.”
- Поради щодо типових помилок (неправильний ID, помилка у селекторі тощо).

#### **E. Підтримуюче середовище:**
- Заохочуйте ділитись своїм кодом.
- Пропонуйте перевірку й фідбек на їхній підхід.