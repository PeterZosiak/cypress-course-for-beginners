## **Урок 5: Введение в DOM: свойства, методы и глобальный объект `window`**

### **1. Структура содержания**

#### **A. Введение в DOM (Document Object Model – Объектная модель документа)**
- **Что такое DOM?**
  - Определение и назначение.
  - Представление веб-страницы в виде древовидной структуры.
- **Доступ к элементам DOM:**
  - `document.getElementById()`.
  - `document.querySelector()` и `document.querySelectorAll()`.
- **Манипулирование элементами DOM:**
  - Изменение содержимого (`innerText`, `innerHTML`).
  - Модификация атрибутов (`setAttribute()`, `getAttribute()`).
  - Добавление и удаление классов (`classList.add()`, `classList.remove()`).
- **Обработка событий:**
  - Добавление обработчиков событий (`addEventListener()`).
  - Общие события (click, input, submit).


##### Что такое DOM?

**Определение:**  
Document Object Model (DOM, объектная модель документа) — это программный интерфейс, который отображает структуру HTML- или XML-документа в виде дерева объектов. Каждый элемент, атрибут и фрагмент текста становится объектом, что позволяет разработчикам программно изменять структуру, стиль и содержимое страницы.

**Ключевые характеристики:**
- **Древовидная структура:** Документ представлен в виде иерархического дерева узлов.
- **Скриптовый интерфейс:** JavaScript может взаимодействовать с DOM-узлами, изменяя отображение в браузере.
- **Динамические обновления:** Позволяет изменять элементы, атрибуты и содержимое на лету без перезагрузки всей страницы.

**Примеры использования в автоматизации тестирования:**
- Выбор элементов для проверки их наличия, атрибутов или текста.
- Симуляция действий пользователя (клики, ввод) над элементами DOM.
- Проверка появления или исчезновения элементов после определённых действий.


##### Обработка событий в DOM

**Определение:**  
Обработка событий — это процесс обнаружения и реакции на взаимодействия пользователя или события, инициированные браузером, на веб-странице. События могут включать клики мыши, нажатия клавиш, отправку форм, движение мыши или другие действия пользователя.

**Ключевые характеристики:**
- **Обработчики событий:** Функции, которые выполняются при наступлении определённых событий.
- **Асинхронное поведение:** События происходят асинхронно, инициируются действиями пользователя или планируются по времени.
- **Контроль взаимодействия:** Позволяет разработчикам (и тестировщикам) симулировать и тестировать реакцию приложения на ввод пользователя.

**Примеры использования в автоматизации тестирования:**
- Проверка взаимодействий с UI, например, что клик по кнопке вызывает нужное поведение.
- Валидация логики отправки форм или обработки ошибок.
- Проверка, что события ввода с клавиатуры приводят к ожидаемым изменениям на экране.

#### **B. Свойства и методы DOM**

**Что такое свойства элементов DOM?**  
Когда веб-страница загружается в браузер, тот создаёт объектную модель документа (DOM), представляющую структуру страницы в виде дерева объектов. Каждый HTML-элемент становится объектом DOM, имеющим свойства и методы, к которым можно получить доступ и которыми можно управлять с помощью JavaScript.

- **Свойства DOM-элементов:**
  - `innerText`, `textContent`, `innerHTML`: доступ к тексту и HTML-содержимому элемента, их изменение.
  - `value`: для элементов формы, таких как input, позволяет получить или установить введённое пользователем значение.
  - `style`: доступ к встроенным CSS-свойствам.
  - `classList`: добавление, удаление или переключение CSS-классов без редактирования атрибута class вручную.
- **Распространённые методы DOM:**
  - **Методы выбора:**
    - `document.getElementById('id')`: выбор элемента по ID.
    - `document.querySelector('selector')`: выбор первого элемента, подходящего под CSS-селектор.
    - `document.querySelectorAll('selector')`: выбор всех элементов по CSS-селектору, возвращает NodeList.
  - **Пользовательские атрибуты:**
    - `data-*`: специальные атрибуты для хранения дополнительной информации об элементе, не влияющей изначально на его внешний вид или поведение. Особенно полезны в JavaScript для передачи дополнительного контекста или настроек элементам.
    - Data-атрибуты очень удобны в автоматизации тестирования. Например, с помощью data-cy, data-test или data-testid можно создавать надёжные селекторы, устойчивые к изменениям в UI. Эти атрибуты не видны пользователям и могут меняться без влияния на внешний вид страницы. В Cypress можно использовать селектор cy.get('[data-test="login-button"]'), чтобы стабильно находить элемент.
  
  - **Методы манипуляции:**
    - `element.appendChild(node)`: добавляет новый дочерний узел к элементу.
    - `element.removeChild(node)`: удаляет дочерний узел.
    - `element.setAttribute('name', 'value')`: устанавливает или изменяет атрибут элемента.
    - `element.removeAttribute('name')`: удаляет атрибут.
  - **Обработка событий (кратко):**
    - `element.addEventListener('event', callback)`: прикрепляет обработчик события к элементу DOM.
  - **Использование управляющих и структур данных:**
    - Циклы и условия для динамического обновления DOM (например, проход по массиву данных для создания списка элементов).
    - Объекты для хранения селекторов или ссылок на элементы DOM для повторного использования.
    - Получение данных из JSON и заполнение элементов, обновляя DOM "на лету".


1. **`innerText` / `textContent`:**
   - **Назначение:** Получить или изменить текстовое содержимое элемента.
   - **Пример:**
     ```javascript
     const heading = document.getElementById('main-title');
     console.log(heading.innerText); // Считывает отображаемый текст заголовка
     heading.innerText = "Welcome to the Dashboard!";
     ```
   - **Различия:** `innerText` учитывает CSS-стили и скрытые элементы, а `textContent` показывает весь текст, включая скрытые элементы и переносы строк.

2. **`innerHTML`:**
   - **Назначение:** Получить или изменить HTML-разметку внутри элемента.
   - **Пример:**
     ```javascript
     const container = document.querySelector('#content');
     container.innerHTML = "<p>New paragraph!</p>"; // Вставляет HTML-код
     ```
   - **Внимание:** Использование `innerHTML` с недоверенными данными может привести к риску XSS (межсайтовый скриптинг).

3. **`value`:**
   - **Назначение:** Для элементов форм (input, textarea) позволяет получить или установить значение, введённое пользователем.
   - **Пример:**
     ```javascript
     const input = document.getElementById('username');
     input.value = "testUser";
     ```

4. **`classList`:**
   - **Назначение:** Управлять CSS-классами элемента без необходимости вручную изменять строку атрибута class.
   - **Пример:**
     ```javascript
     const button = document.querySelector('.btn');
     button.classList.add('active');
     button.classList.remove('disabled');
     button.classList.toggle('hidden');
     ```

5. **`style`:**
   - **Назначение:** Получить или изменить встроенные CSS-стили элемента.
   - **Пример:**
     ```javascript
     const box = document.querySelector('.box');
     box.style.backgroundColor = "blue";
     box.style.color = "white";
     ```
   - **Примечание:** Обычно лучше управлять стилями через классы и внешний CSS для удобства поддержки.

##### Доступ к элементам DOM

**Выбор элементов:**
```html
<!-- index.html -->
<div id="container">
  <h1 class="title">Hello, World!</h1>
  <button id="clickMeBtn">Click Me</button>
</div>
```

```javascript
// JavaScript
const container = document.getElementById("container");
const title = document.querySelector(".title");
const button = document.querySelector("#clickMeBtn");
```

**Рекомендации:**
- Используйте `document.getElementById()` для выбора по ID ради производительности.
- Используйте `document.querySelector()` и `document.querySelectorAll()` для сложных или гибких селекторов.
- Придумывайте осмысленные ID и имена классов для читаемости селекторов.

##### Манипулирование элементами DOM

**Изменение содержимого:**
```javascript
title.innerText = "Welcome to the Test Page!";
```

**Изменение атрибутов:**
```javascript
button.setAttribute("disabled", "true");
console.log(button.getAttribute("id")); // "clickMeBtn"
```

**Изменение классов:**
```javascript
title.classList.add("highlight");
title.classList.remove("old-class");
```

**Рекомендации:**
- Минимизируйте прямое взаимодействие с DOM — кешируйте ссылки на элементы.
- Для изменения стиля используйте классы и CSS, а не inline-стили.
- Группируйте операции с DOM для снижения нагрузки на производительность.

##### Обработка событий

**Добавление обработчиков событий:**
```javascript
button.addEventListener("click", function () {
  console.log("Button was clicked!");
  container.innerHTML += "<p>Button Clicked!</p>";
});
```

**Рекомендации:**
- Используйте ненавязчивую обработку событий (`addEventListener`), а не inline-атрибуты вроде `onclick`.
- Давайте обработчикам событий осмысленные имена:
  
```javascript
function handleButtonClick(event) {
  console.log("Button clicked:", event.target);
}

button.addEventListener("click", handleButtonClick);
```

- Удаляйте обработчики событий, если они больше не нужны, чтобы избежать утечек памяти:
  
```javascript
button.removeEventListener("click", handleButtonClick);
```


#### **B. Глобальный объект `window`**
**Определение:**  
В веб-браузерах объект `window` — это глобальный объект, представляющий окно браузера, содержащее вашу веб-страницу. Все глобальные переменные, функции и объекты становятся свойствами объекта `window`.

- **Что такое объект `window`?**
  - Глобальный объект в браузерной среде.
  - Представляет окно браузера и предоставляет методы и свойства для его управления.
- **Ключевые свойства и методы `window`:**
  - **Свойства:**
    - `window.document`: ссылается на DOM текущей страницы.
    - `window.location`: информация об URL и навигации.
    - `window.history`: доступ к истории браузера.
    - `window.localStorage` и `window.sessionStorage`: хранение и получение данных в браузере.
  - **Методы:**
    - `window.alert('message')`: показывает всплывающее окно с сообщением.
    - `window.confirm('message')`: окно подтверждения (да/нет), возвращает true или false.
    - `window.setTimeout(callback, milliseconds)`: задерживает выполнение кода.
    - `window.setInterval(callback, milliseconds)`: периодически выполняет код.
  - **Неявная глобальная область видимости:**
    - Переменные, объявленные на верхнем уровне (без `let`, `const` или `var` — в старом коде), могут стать свойствами `window` (что не рекомендуется).
    - Знание областей видимости (см. предыдущие уроки) помогает избежать загрязнения глобального пространства имён.


**Ключевые моменты о `window`:**
- **Глобальная область:** Глобально объявленные переменные (без `let`, `const` или `var` — в старом коде) могут стать свойствами `window`. В современных лучших практиках избегайте этой особенности.
- **Доступ к документу и API браузера:**  
  - `window.document` даёт доступ к DOM текущей страницы.  
  - `window.location` предоставляет информацию и методы для работы с URL.  
  - `window.history` позволяет управлять историей браузера.  
  - `window.alert()`, `window.confirm()`, `window.prompt()` отображают диалоговые окна.  
  - `window.setTimeout()` и `window.setInterval()` задают выполнение кода по времени.

**Пример:**
```javascript
console.log(window.location.href); // Показывает текущий URL страницы
window.alert("Welcome to the site!");
```

**Лучшая практика:**  
Не размещайте лишние данные на объекте `window`. Держите переменные внутри функций или модулей, чтобы избежать загрязнения глобального пространства имён.

#### **D. Лучшие практики работы с DOM и `window`**
- **Поддерживаемость кода:**
  - Храните ссылки на часто используемые элементы в переменных.
  - Используйте осмысленные имена переменных для DOM-ссылок и избегайте "магических строк".
- **Производительность:**
  - Минимизируйте ненужные операции с DOM — выполняйте изменения пакетами или используйте методы, сокращающие количество перерисовок.
  - Для генерации или обновления DOM переиспользуйте массивы, объекты и JSON-данные, а не хардкодьте элементы.
- **Безопасность и валидация данных:**
  - Не вставляйте в `innerHTML` непроверенные данные (риск XSS).
  - Валидируйте JSON и пользовательский ввод до добавления в DOM.
- **Использование управляющих конструкций:**
  - Используйте циклы и условия для динамического обновления DOM исходя из действий пользователя или данных из API.
  - Например, у вас есть массив объектов продуктов в JSON — обходите его циклом, чтобы для каждого элемента создать DOM-элемент.

#### **E. Практические примеры**

1. **Доступ к содержимому элемента и обновление:**
   ```javascript
   const title = document.getElementById('page-title');
   title.innerText = "Welcome to the Dashboard!";
   ```

2. **Изменение атрибутов элемента и классов:**
   ```javascript
   const loginButton = document.querySelector('#login-btn');
   loginButton.setAttribute('disabled', 'true');

   const mainHeader = document.querySelector('h1');
   mainHeader.classList.add('highlighted');
   mainHeader.classList.remove('old-class');
   ```

3. **Динамическое создание и добавление элементов:**
   ```javascript
   const userList = document.getElementById('user-list');
   const users = [
     { name: "Alice", role: "admin" },
     { name: "Bob", role: "user" },
     { name: "Charlie", role: "moderator" }
   ];

   users.forEach(user => {
     const li = document.createElement('li');
     li.innerText = `${user.name} (${user.role})`;
     userList.appendChild(li);
   });
   ```

4. **Получение JSON-данных и обновление DOM:**
   
**Что такое `fetch()`?**  
`fetch()` — встроенная функция JavaScript (часть Fetch API), позволяющая выполнять сетевые запросы, например, получать данные по URL. Она возвращает Promise, что облегчает обработку асинхронных операций без блокировки основного потока выполнения.

   ```javascript
   fetch('users.json')
     .then(response => response.json())
     .then(data => {
       const userContainer = document.querySelector('#user-container');
       data.forEach(user => {
         const div = document.createElement('div');
         div.innerText = `${user.name} - ${user.email}`;
         userContainer.appendChild(div);
       });
     });
   ```

  5. **setTimeout**
  **Что такое `setTimeout()`?**  
`setTimeout()` — функция браузера (доступна через `window`), позволяющая выполнить заданную функцию через определённую задержку (в миллисекундах).

**Синтаксис:**
```javascript
window.setTimeout(() => {
  console.log("This message appears after 2 seconds");
}, 2000);
```

**Параметры:**
1. **Callback Function (функция обратного вызова):** Функция, которая будет выполнена после задержки.
2. **Delay (milliseconds, миллисекунды):** Время ожидания до вызова callback-функции. 1000 мс = 1 секунда.

**Поведение:**
- Callback не будет выполнен до истечения указанной задержки.
- Код не блокируется — callback планируется, а скрипт продолжает выполнение. После окончания времени callback функция выполнится.

**Использование в автоматизации тестирования:**
- **Симуляция ожиданий пользователя:** Например, проверка того, как UI себя ведёт после задержки (пропадает спиннер загрузки спустя несколько секунд).
- **Планирование асинхронных проверок:** Запуск кода спустя время для проверки, что в DOM произошло нужное изменение.

**Остановка тайм-аута:**
- Присвоив результат `setTimeout()` переменной, можно отменить таймер с помощью `clearTimeout()`.
  ```javascript
  const timeoutId = setTimeout(() => {
    console.log("Will this message appear?");
  }, 5000);

  // Отмена тайм-аута до его срабатывания
  clearTimeout(timeoutId);
  ```
   
**Значение JSON в автоматизации тестирования:**  
JSON (JavaScript Object Notation) — лёгкий формат обмена данными, легко читаемый человеком и машиной. Не зависит от языка программирования и широко используется для взаимодействия клиента и сервера. В автоматизации тестирования:

1. **Фикстуры и тестовые данные:**  
   Тестовые входные данные и ожидаемые результаты можно хранить в JSON-файлах. Это разделяет данные и тестовую логику, упрощает поддержку и повторное использование сценариев.

2. **API-тестирование:**  
   При тестировании приложений, общающихся с бэкендом по API, ответы чаще всего приходят в формате JSON. Парсинг и сравнение фактических и ожидаемых данных происходит просто.

3. **Мокирование ответов:**  
   В автотестах можно подменять ответы заранее подготовленными JSON-данными. Это делает тесты детерминированными и не зависимыми от внешних сервисов.

**Парсинг и обработка JSON:**
- **Метод `response.json()`:**  
  После вызова `fetch()` обычно преобразуют "сырые" данные ответа в формат JSON:
  ```javascript
  fetch('users.json')
    .then(response => response.json()) // парсит JSON из ответа
    .then(data => {
      console.log(data);
      // теперь data — это объект/массив JS, с которым можно работать
    });
  ```

#### Что такое `then` у функции `fetch()`?

**Объяснение:**  
`then()` — это метод объектов Promise. Вызов `fetch()` возвращает Promise. `then()` определяет, что делать, когда Promise исполнился (т.е. асинхронная операция завершилась успешно).

- **Первый `.then()`:** Обычно используется для преобразования "сырого" ответа `fetch()` в пригодный формат (например, JSON).
- **Второй `.then()`:** После парсинга можно добавить следующий `then()`, чтобы обработать данные (например, обновить DOM, провести проверки и т.д.).

**Пример:**
```javascript
fetch('users.json')
  .then(response => response.json())    // Преобразует тело ответа в JSON
  .then(data => {
    console.log(data);                  // Используйте полученные данные здесь
  })
  .catch(error => console.error(error));
```

**Ключевые моменты:**  
- **`then()`** позволяет выстраивать цепочку действий в асинхронных операциях. Каждый `then()` возвращает новый Promise, что позволяет строить такие цепочки.
- **`catch()`** используется для обработки ошибок на любом этапе цепочки.


5. **Использование объекта `window`:**
   ```javascript
   console.log(window.location.href); // Текущий URL страницы
   window.setTimeout(() => {
     alert("Time’s up!");
   }, 2000);
   ```

#### **F. Связь с предыдущими уроками**
- **Массивы и объекты:**
  - Используйте массивы для хранения списков данных и итерации по ним для динамического создания DOM-элементов.
  - Используйте объекты для хранения селекторов или ссылок на элементы для удобства работы с DOM.
- **JSON и работа с API:**
  - Получайте JSON-данные и используйте их для наполнения элементов страницы.
- **Управляющие конструкции:**
  - Используйте конструкции `if/else`, циклы и логические условия для выбора способа и времени обновления DOM, обработки вводимых пользователем данных, изменения свойств `window` и т.д.
- **Комбинирование концепций:**
  - Все изученное — переменные, функции, массивы, объекты, JSON, манипуляция DOM, обработка событий — теперь можно комбинировать для создания интерактивных и динамических веб-приложений.

---

### **2. Практические задания: упражнения и предложения по веб-функционалу**

#### **A. Взаимодействие с DOM в тестах – упражнение**
- **Упражнение:**
  - Создайте HTML-страницу с различными элементами: кнопки, поля ввода, контейнеры.
  - Напишите Cypress-тесты, которые:
    - Выбирают и взаимодействуют с элементами DOM по селекторам.
    - Проверяют наличие и содержимое элементов.
    - Симулируют действия пользователя: клики, отправку формы.
  - **Пример:**
    ```html
    <!-- index.html -->
    <!DOCTYPE html>
    <html>
    <head>
      <title>DOM Interaction Test</title>
    </head>
    <body>
      <h1 id="title">Welcome to the Test Page</h1>
      <button id="changeTitle">Change Title</button>
      <input type="text" id="username" placeholder="Enter username" />
      <button id="submitForm">Submit</button>
      <div id="output"></div>

      <script>
        document.getElementById('changeTitle').addEventListener('click', () => {
          document.getElementById('title').innerText = 'Title Changed!';
        });

        document.getElementById('submitForm').addEventListener('click', () => {
          const username = document.getElementById('username').value;
          document.getElementById('output').innerText = `Hello, ${username}!`;
        });
      </script>
    </body>
    </html>
    ```

    ```javascript
    // Cypress Test
    describe('DOM Interaction Test', () => {
      beforeEach(() => {
        cy.visit('/index.html');
      });

      it('Changes the title when button is clicked', () => {
        cy.get('#changeTitle').click();
        cy.get('#title').should('have.text', 'Title Changed!');
      });

      it('Submits the form and displays greeting', () => {
        cy.get('#username').type('TestUser');
        cy.get('#submitForm').click();
        cy.get('#output').should('have.text', 'Hello, TestUser!');
      });
    });
    ```

- **Предложение по веб-функционалу:**
  - Разработайте динамичную страницу, где пользователь может:
    - Изменять заголовок страницы по клику на кнопку.
    - Отправлять форму с именем пользователя и видеть индивидуальное приветствие.
  - Напишите Cypress-тесты для автоматической проверки этих взаимодействий.


#### **B. Упражнение на обновление содержимого DOM**
- **Упражнение:**
  - Создайте простую страницу с заголовком, параграфом и кнопкой.
  - Напишите код на JavaScript, который:
    - Меняет текст заголовка с помощью `innerText` при загрузке страницы.
    - Обновляет текст параграфа по нажатию кнопки.
  - **Предложение по веб-функционалу:**
    - "Welcome"-страница: сначала выводит общее сообщение, а при нажатии кнопки — персонализированное приветствие.

#### **C. Упражнение: динамическое создание списка на основе JSON**
- **Упражнение:**
  - Создайте JSON-файл (`products.json`) с массивом объектов продуктов (`name`, `price`, `category`).
  - Используйте `fetch()` для загрузки данных.
  - Динамически создайте список товаров на странице, выводя имя и цену каждого продукта.
  - **Предложение по веб-функционалу:**
    - Страница каталога товаров: получает данные и отображает их в виде таблицы/списка, обновляемого при изменении данных.

#### **D. Упражнение с методами `window`**
- **Упражнение:**
  - Покажите оповещение через 2 секунды с помощью `window.setTimeout()`.
  - Выведите текущий URL страницы через `window.location.href`.
  - Реализуйте кнопку "Обновить", которая перезагружает страницу с помощью `window.location.reload()`.
  - **Предложение по веб-функционалу:**
    - Страница с таймером уведомления и кнопкой обновления — демонстрация приёмов работы с `window`.

---

### **3. Возможные вопросы от студентов**

1. **В чём разница между `document.getElementById()` и `document.querySelector()`?**
   - **Ответ:**  
     `document.getElementById()` выбирает элемент по уникальному ID и обычно работает быстрее. `document.querySelector()` позволяет выбирать элементы по любому CSS-селектору, что даёт больше гибкости.

2. **Как изменить содержимое элемента DOM в JavaScript?**
   - **Ответ:**  
     Используйте свойства `innerText`, `innerHTML` или `textContent`. Например:
     ```javascript
     document.getElementById('title').innerText = 'New Title';
     ```

3. **Когда использовать `innerText`, а когда `innerHTML`?**  
   **Ответ:**  
   - `innerText` устанавливает/получает читаемый пользователем текст внутри элемента, игнорирует HTML-теги.
   - `innerHTML` позволяет добавить или изменить HTML-код внутри элемента. Используйте его осторожно, чтобы избежать XSS-уязвимостей.

4. **Как избежать загрязнения глобальной области переменных с объектом `window`?**  
   **Ответ:**  
   - Всегда объявляйте переменные через `let` или `const` внутри функций или блоков.
   - Используйте модули или замыкания для локализации переменных.
   - Не храните данные на `window` — используйте объекты или модули.

5. **В чём разница между `document.getElementById()` и `document.querySelector()`?**  
   **Ответ:**  
   - `getElementById()` выбирает элемент по уникальному ID и возвращает один элемент.
   - `querySelector()` использует CSS-селектор, может выбрать любой подходящий элемент, и тоже возвращает только первый найденный.
   - `querySelector()` универсальнее, но `getElementById()` быстрее, если нужен элемент по ID.

6. **Можно ли перебирать коллекции DOM-элементов, как массивы?**  
   **Ответ:**  
   - `querySelectorAll()` возвращает NodeList, который можно обрабатывать методом `forEach()`.
   - Также можно преобразовать NodeList или HTMLCollection в массив с помощью `Array.from()` и использовать все стандартные методы массива.

---

### **4. Дополнительные материалы: рекомендации**

#### **A. Официальная документация и гайды:**
- [MDN Web Docs - Введение в DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction)
- [MDN Web Docs - Объект Window](https://developer.mozilla.org/en-US/docs/Web/API/Window)
- [MDN Web Docs - Манипуляции с DOM](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents)

#### **B. Туториалы и статьи:**
- **W3Schools DOM Tutorial:** [https://www.w3schools.com/js/js_htmldom.asp](https://www.w3schools.com/js/js_htmldom.asp)
- **JavaScript.info DOM Tutorial:** [https://javascript.info/document](https://javascript.info/document)

#### **C. Интерактивные обучающие платформы:**
- **FreeCodeCamp:** упражнения по работе с DOM и обработке событий.
- **Codecademy:** интерактивные уроки по работе с DOM.

#### **D. Видеоуроки:**
- **Traversy Media на YouTube:** видео по основам манипуляции DOM.
- **The Net Ninja:** видеоруководства по DOM — свойства, методы, объект `window`.

#### **E. Платформы для практики:**
- Создавайте небольшие демонстрационные страницы — экспериментируйте с разными методами работы с DOM.
- Используйте JSON-файлы для хранения информации и динамического вывода элементов UI на основе данных.

#### **F. Сообщество и поддержка:**
- **Stack Overflow** и **Reddit** (`r/javascript`): отличные ресурсы для вопросов, связанных с DOM.
- **Discord-сообщества:** присоединяйтесь к JavaScript-каналам и фронтенд-сообществам для обсуждения вопросов о DOM.

---

### **5. Примерное распределение урока на 3 часа**

#### **1-й час: Свойства и методы DOM (60 минут)**
- **Повторение основных понятий DOM (10 минут):**
  - Обзор структуры DOM и того, как JavaScript "видит" страницу.
- **Свойства и методы DOM (40 минут):**
  - `innerText`, `innerHTML`, `textContent`.
  - `classList` и `style`.
  - Создание, изменение и удаление элементов.
- **Краткий Q&A (10 минут):**
  - Ответы на вопросы по ходу дела.

#### **2-й час: Глобальный объект Window и интеграции (60 минут)**
- **Изучение `window` (20 минут):**
  - `window.document`, `window.location`, `window.history`.
  - Таймеры (`setTimeout`, `setInterval`).
- **Практические интеграции с данными (20 минут):**
  - Получение JSON-данных и обновление DOM.
  - Применение циклов и условий для построения интерфейса.
- **Краткий Q&A (10 минут):**
  - Уточнения, вопросы.
- **Перерыв (10 минут):**
  - Короткая пауза.

#### **3-й час: Практика и лучшие практики (60 минут)**
- **Практические задания (40 минут):**
  - Обновление текста и атрибутов.
  - Создание списков на основе массивов или JSON.
  - Использование методов `window` для отображения оповещений или перезагрузки страницы.
- **Ревью и Q&A (20 минут):**
  - Повторение ключевых идей и лучших приёмов.
  - Призыв к экспериментам и самостоятельному освоению сложных манипуляций с DOM.

---

### **6. Дополнительные рекомендации**

#### **A. Интерактивные демонстрации:**
- Покажите примеры live-кодинга:
  - Получение и отображение данных из JSON.
  - Изменение классов элементов по клику на кнопку.
  - Таймерное оповещение через `setTimeout()`.

#### **B. Эффективные иллюстрации:**
- Используйте схемы для визуализации дерева DOM.
- Блок-схемы, показывающие поток данных от JSON к DOM-элементам.
- Акцентируйте, что `window` — верхний уровень браузерного окружения.

#### **C. Стимулируйте вовлечённость:**
- Попросите студентов найти и вывести `window.location.href`.
- Пусть самостоятельно создают и удаляют элементы.
- Экспериментируйте с различными методами и свойствами выбора элементов.

#### **D. Чёткие инструкции:**
- Давайте пошаговые задания: например, "Изменить заголовок и добавить новый параграф под ним".
- Давайте советы по устранению типичных ошибок (например, ошибка в селекторе или ID).

#### **E. Поддержка и обратная связь:**
- Поощряйте студентов делиться своими сниппетами кода.
- Предлагайте проверить, обсудить и дать обратную связь по их решениям.