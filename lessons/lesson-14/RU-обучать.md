## **Урок 14: Использование baseUrl и контекстов в Cypress**

### **Цели**

- Использовать конфигурацию `baseUrl` для упрощения навигации в тестах и работы с относительными URL.
- Понимать и структурировать тесты с помощью контекстов для управления разными сценариями.
- Применять продвинутые команды Cypress, такие как `cy.origin` для работы с несколькими доменами.
- Внедрять лучшие практики структуры тестов и поддержки кода.

---

### **Разбор содержимого**

#### **A. baseUrl**

1. **Настройка baseUrl в конфигурации Cypress:**
   - **Определение:**  
     `baseUrl` — это параметр конфигурации в Cypress, определяющий корневой URL для всех ваших тестов. Это позволяет использовать относительные адреса в командах типа `cy.visit('/')`.
   - **Пример:**
     ```javascript
     // cypress.config.js
     import { defineConfig } from 'cypress';

     export default defineConfig({
       e2e: {
         baseUrl: 'http://localhost:3000',
         // Другие настройки…
       },
     });
     ```

2. **Преимущества использования baseUrl:**
   - **Упрощение:**  
     Нет необходимости повторять полный URL в тестах, используйте относительные пути.
   - **Гибкость:**  
     Легко переключаться между окружениями, переопределяя baseUrl (например, разработка, staging, production).
   - **Поддерживаемость:**  
     Централизованная настройка URL: при изменении хоста достаточно обновить один файл.

3. **Переопределение baseUrl для разных окружений:**
   - Используйте переменные окружения или отдельные конфигурационные файлы для изменения baseUrl.
   - **Пример:**
     ```javascript
     // В cypress.config.js с использованием loadEnv (см. урок 12)
     import { defineConfig, loadEnv } from 'vite';
     export default defineConfig(({ mode }) => {
       const env = loadEnv(mode, process.cwd(), ['VITE_']);
       return {
         e2e: {
           baseUrl: env.VITE_API_BASE_URL || 'http://localhost:3000',
           // другие настройки...
         }
       };
     });
     ```
   - С разными .env-файлами (например, `.env.development`, `.env.production`) baseUrl может переключаться соответствующим образом.

---

#### **B. Контексты в Cypress**

1. **Понимание контекстов в Cypress:**
   - **Определение:**  
     Контексты (или логические группы) используются для структурирования тестов, которые имеют общую настройку или относятся к определенному пользовательскому сценарию.
     
   - **Использование:**  
     В Cypress нет специальной функции контекста (`context()` — это просто алиас для `describe()`), вы можете использовать вложенные блоки `describe()` для создания смысловых групп.

2. **Использование контекстов для управления различными сценариями тестирования:**
   - **Пример:**  
     Группируйте тесты по различным состояниям приложения или сценариям (например, "Когда пользователь вошел в систему", "Когда пользователь не вошел в систему").
   - **Пример вложенного describe:**
     ```javascript
     describe('Login Page @login', () => {
       beforeEach(() => {
         cy.visit('/');
       });

       describe('Validation Errors', () => {
         it('should display error when username is missing', () => {
           // Код теста
         });
         it('should display error when password is missing', () => {
           // Код теста
         });
       });

       describe('Successful Login', () => {
         it('should log in successfully with valid credentials', () => {
           // Код теста
         });
       });
     });
     ```

      В терминах Cypress, контекст теста обычно подразумевает среду, в которой запускается тест, а именно:
        - JavaScript scope, в котором выполняется код Cypress,
        - домен (origin) посещаемой страницы,
        - состояние браузера: cookies, localStorage, сессии и даже переменные в памяти.
---

## Мультдоменное тестирование в Cypress

##### **Что такое мультдоменное тестирование?**

Мультдоменное тестирование относится к сценариям, когда ваше приложение охватывает более одного домена или поддомена. Это характерно для случаев, когда приложение:

- Использует стороннюю аутентификацию (например, OAuth-провайдеры, социальные логины).
- Имеет отдельные домены для основного приложения и API.
- Должно взаимодействовать с внешними сервисами или виджетами, размещенными на другом домене.

### **Трудности мультдоменного тестирования**

- **Политика того же источника (Same-Origin Policy):**  
  Браузеры ограничивают JavaScript в доступе к ресурсам с разных доменов. Это затрудняет тестирование взаимодействий между страницами на разных доменах.
  
- **Управление сессиями:**  
  Могут возникнуть сложности с поддержанием и проверкой состояния сессии между доменами, так как cookies и localStorage по умолчанию не разделяются между ними.

- **Целостность потока данных:**  
  Необходимо обеспечить правильную передачу данных между доменами (например, чтобы вход на одном домене давал доступ на другом) — для этого в тестах требуется особая обработка.


#### **C. Продвинутые Cypress-команды: cy.origin и cy.session**

1. **cy.origin: Работа с несколькими доменами**
   - **Назначение:**  
     `cy.origin` позволяет выполнять команды в контексте другого origin (домена). Это полезно, если в вашем приложении есть взаимодействие с несколькими доменами (например, аутентификация через стороннего провайдера).
   - **Пример использования:**
     ```javascript
     // Пример: переход на внешний домен для выполнения действия
     cy.origin('https://external-domain.com', () => {
       cy.get('[data-testid="external-login"]').click();
     });
     ```
   - **Преимущества:**  
     Позволяет тестировать кросс-доменные взаимодействия, сохраняя границы безопасности.

    #### Важность `cy.origin()` при мультдоменном тестировании

    **Что такое `cy.origin()`?**  
    `cy.origin()` — это Cypress-команда, которая позволяет выполнять действия в контексте другого домена, отличного от основного `baseUrl`. Это критично для тестирования взаимодействия между доменами.

    **Почему это важно:**

    - **Обход ограничений Same-Origin Policy:**  
      Позволяет взаимодействовать с элементами или страницами на другом домене. Без `cy.origin()` Cypress выдаст ошибку при попытке получить доступ к ресурсам другого домена.

    - **Реалистичное моделирование пользовательских взаимодействий:**  
      Когда пользователь переходит или взаимодействует с другим доменом (например, платёжная система или OAuth-провайдер), `cy.origin()` позволяет смоделировать такое поведение в тестах.

    - **Бесшовная интеграция:**  
      Можно переключаться между доменами в рамках одного теста, что позволяет покрыть полный пользовательский путь через разные части приложения.

    **Пример использования `cy.origin()`:**

    Допустим, для аутентификации ваше приложение использует сторонний сервис на `https://auth.example.com`, а основное приложение работает на `http://localhost:3000`.

    ```javascript
    // В файле теста для мультдоменной авторизации
    describe('Multidomain Login Test', () => {
      it('should handle login via a third-party authentication service', () => {
        // Открываем страницу основного приложения
        cy.visit('/login');

        // Нажатие на кнопку переводит на внешний домен авторизации
        cy.get('[data-testid="login-with-oauth"]').click();

        // Используем cy.origin() для переключения в контекст внешнего домена
        cy.origin('https://auth.example.com', () => {
          // Взаимодействуем со страницей авторизации
          cy.get('[data-testid="auth-username"]').type('externalUser');
          cy.get('[data-testid="auth-password"]').type('externalPass');
          cy.get('[data-testid="auth-submit"]').click();
        });

        // Возвращаемся на основной домен и проверяем успех авторизации
        cy.url().should('include', '/dashboard');
        cy.get('[data-testid="welcome-message"]').should('contain', 'Welcome');
      });
    });
    ```



### Дополнительные примеры кода для мультдоменного тестирования

**Пример: Переход между несколькими доменами**

Допустим, в тесте после логина в основном приложении нужно посетить маркетинговый сайт на другом домене:

```javascript
describe('Multidomain Navigation', () => {
  it('should navigate from the main app to the marketing site', () => {
    cy.visit('/login');
    cy.get('[data-testid="login-with-oauth"]').click();

    cy.origin('https://auth.example.com', () => {
      cy.get('[data-testid="auth-username"]').type('externalUser');
      cy.get('[data-testid="auth-password"]').type('externalPass');
      cy.get('[data-testid="auth-submit"]').click();
    });

    // После входа, пользователь попадает на маркетинговую страницу на другом домене
    cy.origin('https://marketing.example.com', () => {
      cy.visit('/special-offers');
      cy.get('[data-testid="offer-banner"]').should('be.visible');
    });
  });
});
```
---

#### **D. Упражнения**

1. **Настроить baseUrl и обновить тесты:**
   - **Задание:**  
     Измените тесты на использование `cy.visit('/')` при настроенном `baseUrl` в `cypress.config.js`. 
   - **Цель:**  
     Убедитесь, что в тестах используются относительные пути и что для окружения применен правильный baseUrl.

3. **Экспериментировать с cy.origin и cy.session:**
   - **Задание:**  
     Напишите тест, который переходит на другой домен с помощью `cy.origin` (симулируйте внешнюю аутентификацию).
   - **Цель:**  
     Показать, как работать с мультдоменными сценариями и уменьшить накладные расходы на подготовку среды.

---

#### **E. Примеры команд и конфигурации Cypress**

**Использование baseUrl в тесте:**
```javascript
describe('Home Page Navigation', () => {
  it('should load the login page using relative URL', () => {
    cy.visit('/login'); // Подставляется baseUrl + /login
    cy.get('[data-testid="page-title"]').should('contain', 'Login');
  });
});
```

**Использование cy.origin:**
```javascript
describe('Cross-Origin Login', () => {
  it('should perform login on external domain', () => {
    cy.origin('https://external.example.com', () => {
      cy.get('[data-testid="external-login"]').click();
    });
  });
});
```

---

### **Возможные вопросы студентов и ответы**

1. **Q:** *Как baseUrl помогает упростить наши тесты?*  
   **A:** Настроив baseUrl в конфигурации, вы можете использовать относительные пути в `cy.visit()`, делая ваши тесты чище и проще для поддержки при смене окружения.

2. **Q:** *Что такое контексты в Cypress и зачем они нужны?*  
   **A:** Контексты, реализуемые с помощью вложенных `describe()`, помогают логически группировать тесты (например, по разным пользовательским сценариям). Это делает структуру тестов более организованной и облегчает сопровождение и отладку.

3. **Q:** *Для чего используется cy.origin?*  
   **A:** `cy.origin` позволяет выполнять команды в контексте другого домена. Это удобно для тестирования кросс-доменных сценариев, таких как сторонняя аутентификация.

5. **Q:** *Можно ли переопределить baseUrl для отдельных тестов?*  
   **A:** Хотя baseUrl — это глобальная настройка, вы можете переопределить его в отдельных тестах через абсолютный URL в `cy.visit()`. Однако лучше придерживаться глобального baseUrl для единообразия, если нет особых причин для иного.

6. **Q:** *Какие советы по использованию контекстов в Cypress?*  
   **A:** Структурируйте тесты с помощью вложенных блоков `describe()` с понятными именами. Используйте хуки (beforeEach/afterEach) для подготовки и очистки состояния внутри каждого контекста, чтобы тесты оставались изолированными и поддерживаемыми.

---

### **Типичная кросс-доменная проблема**

```javascript
describe('Cypress lost value', () => {
  var value1
  var value2;
  
  it('10 - navigate and login to domain1 and save value to variable', () => {
    cy.visit('https://domain1.com');
    cy.loginDomain1().then((value) => {
      value1 = value
    })
    value2 = 100
  });

  it('20 - navigate and login to domain2 and with value1 variable', () => {
    cy.visit('https://domain2.com');
    cy.log(value2) 
    cy.loginDomain2(value1)
  })
});
```

#### Почему Cypress сбрасывает всё при смене домена?

Причина — **правила безопасности браузера**:

##### Что происходит?

Когда вы делаете примерно следующее:

```javascript
cy.visit('https://domain1.com');
// какие-то действия...
cy.visit('https://domain2.com');
// тест падает или теряет переменные...
```

Cypress **автоматически сбрасывает весь контекст браузера** при смене origin.

### 🔹 Почему?

Из-за **Same-Origin Policy (SOP)** в браузерах:

* JavaScript с одного происхождения (`https://domain1.com`) не может напрямую работать с содержимым другого (`https://domain2.com`).
* Cypress соблюдает это правило, чтобы **защитить целостность тестов** и избежать **утечки данных или области видимости** между доменами.

Когда Cypress обнаруживает смену origin:

* Он **сбрасывает iframe теста**
* Все **в памяти переменные**, DOM, cookies и JS-контекст **очищаются**
* Это обеспечивает изоляцию тестов и безопасность

---

#### Пример: почему переменная становится `undefined` при смене домена

```javascript
let token;

it('gets token from domain1', () => {
  cy.visit('https://domain1.com');
  cy.getCookie('authToken').then((cookie) => {
    token = cookie.value;
  });
});

it('tries to use token on domain2', () => {
  cy.visit('https://domain2.com');
  cy.log(token); // 🔴 token здесь undefined
});
```

##### В чем проблема?

* Переменная `token` объявлена **на уровне основного файла теста**.
* Когда Cypress переходит на новый домен, он очищает контекст выполнения.
* Поэтому `token` теряется — Cypress начинает с чистого листа.


В Cypress каждый тест (`it`-блок) выполняется в изоляции. Значения переменных, установленные в одном тесте, ненадежно перенесутся в другой. Даже если объявить глобальную переменную (например, `var value1`), Cypress сбрасывает состояние между тестами для изоляции и чтобы тесты не имели скрытых зависимостей. Кроме того, команды Cypress асинхронны, поэтому присваивание `value1` в первом тесте может не завершиться или быть сброшено к началу второго.

**Ключевые моменты:**

- **Изоляция тестов:**  
  Cypress запускает каждый `it`-блок изолированно, чтобы не допустить побочных эффектов. Глобальные переменные не гарантировано сохраняются между тестами.

- **Асинхронность команд:**  
  В первом тесте присваивание через `.then()` может не сохраниться, когда второй тест начинает выполняться — дело в механизме изоляции.

- **Практика:**  
  Вместо глобальных переменных используйте команды Cypress, такие как `cy.session()`, или объединяйте связанные действия в один тест. Для передачи данных можно использовать контекст через closures или пользовательские задачи Cypress.

**Объяснение примера:**

```javascript
describe('Cypress lost value', () => {
  var value1;
  
  it('10 - navigate and login to domain1 and save value to variable', () => {
    cy.visit('https://domain1.com');
    cy.loginDomain1().then((value) => {
      value1 = value // value1 присваивается здесь
    });
    value2 = 100 // value1 присваивается здесь
  });

  it('20 - navigate and login to domain2 and with value1 variable', () => {
    cy.visit('https://domain2.com');
    // Здесь, при запуске теста, value1 и value2 будут undefined из-за сброса
    cy.log(value2) //-> value2 is undefined
    cy.loginDomain2(value1); //-> value1 is undefined
  });  
});
```

Во втором тесте `value1` ― это `undefined`, потому что:
- **Изоляция:** Каждый блок `it` изолирован.
- **Асинхронность:** Даже если value1 присваивается, оно не будет доступно во втором тесте из-за асинхронности и сброса состояния между тестами.


Понимая особенности изоляции тестов и асинхронных команд Cypress, вы сможете строить тесты, не зависящие от внешних переменных.


Когда требуется передать значение между тестами — особенно между разными доменами — важно помнить, что Cypress намеренно изолирует каждый блок `it()`. Это обеспечивает независимость тестов, но означает, что переменные, установленные в одном тесте, не сохраняются для другого. Вот лучшие практики и решения для такой ситуации:

### **Лучшие практики для передачи состояния между тестами**

1. **Делайте тесты независимыми:**  
   В идеале каждый тест должен быть независимым. Если нужно использовать значение из логина на одном домене для другого, объедините шаги в один тест, чтобы значение было доступно при необходимости.

2. **Объединяйте связанные сценарии:**  
   Если оба домена — часть одной пользовательской цепочки (например, логин на domain1, а затем действие на domain2), объединяйте действия в один тест. Так тест будет целостным.

4. **Сохранение данных с помощью cy.task():**  
   Можно сделать кастомную задачу, чтобы хранить данные (например, записывать во временный файл или в память Node.js) и использовать их в других тестах. Это полезно для обмена данными между тестами, даже между доменами.

#### **Примеры решений**

##### **Решение 1: Объединить в один тест**

Если сценарий перехода с domain1 на domain2 — часть одного пользовательского пути, объедините их:
  
```javascript
describe('Multidomain Login Flow', () => {
  it('logs in on domain1 and uses the value on domain2', () => {
    // Шаг 1: заходим на domain1 и получаем value
    cy.visit('https://domain1.com');
    cy.loginDomain1().then((value) => {
      // value доступно здесь
      // Шаг 2: переключаемся на domain2 через cy.origin()
      cy.visit('https://domain2.com');
      cy.origin('https://domain2.com', () => {
        // Используем полученное значение на domain2
        cy.loginDomain2(value).should('succeed');
      });
    });
  });
});
```

##### **Решение 2: Использовать cy.task() для хранения данных между тестами**

Если объединить тесты невозможно, можно использовать кастомную задачу для хранения значения вне контекста самого теста:

1. **Определить задачу в cypress.config.js или отдельном файле:**

```javascript
// В cypress.config.js или файле поддержки
module.exports = defineConfig({
  e2e: {
    setupNodeEvents(on, config) {
      let sharedValue; // Хранилище в памяти

      on('task', {
        saveValue(value) {
          sharedValue = value;
          return null;
        },
        getValue() {
          return sharedValue;
        }
      });
      return config;
    }
  }
});
```

2. **Использование cy.task() в тестах:**

```javascript
describe('Multidomain Flow with Persisted Value', () => {
  it('saves a value from domain1', () => {
    cy.visit('https://domain1.com');
    cy.loginDomain1().then((value) => {
      cy.task('saveValue', value);
    });
  });

  it('retrieves the value and uses it on domain2', () => {
    cy.visit('https://domain2.com');
    cy.task('getValue').then((value) => {
      // Используем значение на domain2
      cy.loginDomain2(value).should('succeed');
    });
  });
});
```


##### **Решение 3: Сохранение в файл**

1. **Определить задачи в функции setupNodeEvents:**

   В вашем `cypress.config.js` (или в файле, импортируемом им) можно создать задачи для записи и чтения из файла. Например:

   ```javascript
   const fs = require('fs');
   const path = require('path');

   module.exports = defineConfig({
     e2e: {
       setupNodeEvents(on, config) {
         // Задача для записи значения в файл
         on('task', {
           writeValue({ filename, value }) {
             const filePath = path.join(__dirname, filename);
             fs.writeFileSync(filePath, JSON.stringify(value));
             return null;
           },
           // Задача для чтения значения из файла
           readValue({ filename }) {
             const filePath = path.join(__dirname, filename);
             if (fs.existsSync(filePath)) {
               const data = fs.readFileSync(filePath, 'utf8');
               return JSON.parse(data);
             }
             return null;
           }
         });
         return config;
       },
       baseUrl: 'http://localhost:3000'
     },
     env: {
       // Специфичные для окружения переменные...
     }
   });
   ```

2. **Использование в тестах:**

   Теперь можно вызвать `cy.task('writeValue', { filename, value })` в одном тесте для сохранения значения, а `cy.task('readValue', { filename })` — в другом для его получения.

   **Пример:**

   ```javascript
   describe('Store and Retrieve Value from File', () => {
     it('should save a value from domain1 to a file', () => {
       cy.visit('https://domain1.com');
       // Предположим, cy.loginDomain1() возвращает значение для сохранения
       cy.loginDomain1().then((value) => {
         // Сохраняем значение в файл "sharedValue.json"
         cy.task('writeValue', { filename: 'cypress/sharedValue.json', value });
       });
     });

     it('should retrieve the value from file and use it on domain2', () => {
       cy.visit('https://domain2.com');
       cy.task('readValue', { filename: 'cypress/sharedValue.json' }).then((value) => {
         // Используем полученное значение; теперь оно не undefined
         cy.loginDomain2(value).should('succeed');
       });
     });
   });
   ```

  ##### **Преимущества хранения данных в файле:**

  - **Сохранность:**  
    Данные сохраняются даже если тесты выполняются в разных процессах или сессиях.
    
  - **Отладка:**  
    Можно вручную открыть файл и посмотреть, что было сохранено.

  - **Изоляция:**  
    Можно использовать файлы для передачи данных между параллельными или полностью разными тестовыми наборами.

  ### **Недостатки:**

  - **Задержки на I/O:**  
    Файловые операции медленнее, чем операции с памятью.
    
  - **Сложность:**  
    Понадобится очищать файлы и следить за их жизненным циклом.

  - **Возможные флаки:**  
    При одновременной записи в один файл из разных тестов могут возникать условия гонки. Важно обеспечить уникальные файлы и чистку по завершению.

  ### **Рекомендации:**

  - **Уникальные имена файлов:**  
    Используйте разные имена файлов для разных сценариев, чтобы избежать конфликтов.
    
  - **Очистка:**  
    Удаляйте/очищайте файлы после тестов, чтобы избежать использования устаревших данных.
    
  - **Обработка ошибок:**  
    Продумайте обработку ошибок (например, файл не найден), чтобы тесты падали корректно.

  Использование файлов через `cy.task()` — это надежное решение для сохранения состояния между тестами, особенно когда другие методы (глобальные переменные или `cy.session()`) не подходят. Это особенно полезно при работе с множеством доменов или сессий, когда нужен обмен данными вне самого Cypress.