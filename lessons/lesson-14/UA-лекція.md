## **Урок 14: Використання baseUrl та Contexts у Cypress**

### **Мета**

- Використовувати налаштування `baseUrl` для спрощення навігації у тестах і використання відносних URL.
- Розуміти та організовувати тести за допомогою контекстів для керування різними сценаріями.
- Використовувати розширені команди Cypress, такі як `cy.origin` для роботи з кількома доменами.
- Реалізувати найкращі практики для структурування та підтримки тестів.

---

### **Зміст уроку**

#### **A. baseUrl**

1. **Налаштування baseUrl у конфігурації Cypress:**
   - **Визначення:**  
     `baseUrl` — це конфігураційний параметр у Cypress, який визначає кореневий URL для усіх ваших тестів. Це дозволяє використовувати відносні URL у командах, таких як `cy.visit('/')`.
   - **Приклад:**
     ```javascript
     // cypress.config.js
     import { defineConfig } from 'cypress';

     export default defineConfig({
       e2e: {
         baseUrl: 'http://localhost:3000',
         // Інші налаштування…
       },
     });
     ```

2. **Переваги використання baseUrl:**
   - **Спрощення:**  
     Не потрібно повторювати повний URL в тестах; використовуйте відносні шляхи.
   - **Гнучкість:**  
     Легко перемикати середовища шляхом заміни baseUrl (наприклад, розробка, staging, продакшн).
   - **Підтримка:**  
     Централізоване налаштування URL; якщо адреса зміниться, потрібно оновити лише один файл.

3. **Зміна baseUrl для різних середовищ:**
   - Використовуйте змінні середовища або окремі конфігураційні файли для зміни baseUrl.
   - **Приклад:**
     ```javascript
     // у cypress.config.js з loadEnv (див. урок 12)
     import { defineConfig, loadEnv } from 'vite';
     export default defineConfig(({ mode }) => {
       const env = loadEnv(mode, process.cwd(), ['VITE_']);
       return {
         e2e: {
           baseUrl: env.VITE_API_BASE_URL || 'http://localhost:3000',
           // інші налаштування...
         }
       };
     });
     ```
   - З різними .env-файлами (наприклад, `.env.development`, `.env.production`) baseUrl можна перемикати відповідно.

---

#### **B. Контексти у Cypress**

1. **Розуміння контекстів у Cypress:**
   - **Визначення:**  
     Контексти (або логічні групи) використовують для організації тестів із спільною підготовкою або для певних сценаріїв користувача.
     
   - **Використання:**  
     У Cypress немає окремої функції context (оскільки `context()` це лише псевдонім для `describe()`), але можна використовувати вкладені блоки `describe()` для створення логічних груп.

2. **Використання контекстів для керування різними тестовими сценаріями:**
   - **Приклад:**  
     Групування тестів за станами застосунку (наприклад, "Коли користувач увійшов", "Коли не увійшов").
   - **Приклад вкладених describe:**
     ```javascript
     describe('Сторінка входу @login', () => {
       beforeEach(() => {
         cy.visit('/');
       });

       describe('Помилки валідації', () => {
         it('повинна показати помилку, якщо логін не введений', () => {
           // Тестовий код
         });
         it('повинна показати помилку, якщо пароль не введений', () => {
           // Тестовий код
         });
       });

       describe('Успішний вхід', () => {
         it('повинна успішно увійти з валідними даними', () => {
           // Тестовий код
         });
       });
     });
     ```

     У Cypress контекст тесту зазвичай включає:
      - JavaScript-середовище, у якому виконується ваш код.
      - Домен (origin) сторінки, яку ви відвідуєте.
      - Стан браузера: cookies, localStorage, сесії, навіть змінні в пам’яті.
---

## Тестування кількох доменів у Cypress

##### **Що таке Multidomain Testing?**

Мультидоменне тестування — це сценарії, коли ваш застосунок охоплює більше ніж один домен чи піддомен. Це типово, коли ваш додаток:

- Використовує сторонню авторизацію (OAuth-провайдери, соціальні логіни тощо).
- Має окремі домени для основного застосунку та API.
- Потрібно взаємодіяти з зовнішніми сервісами чи віджетами на іншому домені.

### **Виклики при мултидоменному тестуванні**

- **Політика Same-Origin:**  
  Браузери обмежують доступ JavaScript до ресурсів інших доменів. Це ускладнює тестування взаємодії сторінок з різних доменів.
  
- **Керування сесією:**  
  Управління та перевірка стану сесій між доменами складна, бо cookies та localStorage типово не поширюються між різними доменами.

- **Цілісний потік даних:**  
  Гарантія коректної передачі даних з одного домену на інший (наприклад, коли вхід на одному домені дає доступ на іншому) потребує спеціальної обробки у тестах.


#### **C. Розширені команди Cypress: cy.origin та cy.session**

1. **cy.origin: Робота з кількома доменами**
   - **Призначення:**  
     `cy.origin` дозволяє виконувати команди в контексті іншого origin (домену). Це корисно, коли ваш застосунок взаємодіє з кількома доменами (наприклад, автентифікація через сторонній сервіс).
   - **Приклад використання:**
     ```javascript
     // Приклад: Перехід на зовнішній домен для виконання дії
     cy.origin('https://external-domain.com', () => {
       cy.get('[data-testid="external-login"]').click();
     });
     ```
   - **Переваги:**  
     Дозволяє тестувати взаємодію між доменами, дотримуючись при цьому відмежування безпеки.

    #### Важливість `cy.origin()` при тестуванні кількох доменів

    **Що таке `cy.origin()`?**  
    `cy.origin()` — це команда Cypress, що дозволяє виконувати команди у контексті іншого origin, ніж основний `baseUrl`. Це критично важливо для багатодоменного тестування.

    **Чому це важливо:**

    - **Обхід обмежень Same-Origin:**  
      Дозволяє взаємодіяти з елементами чи сторінками на іншому домені. Без `cy.origin()` Cypress видавав би помилки при доступі до ресурсів іншого домену.

    - **Реалістична взаємодія користувача:**  
      Коли користувача перенаправляють на інший домен (наприклад, платіжний шлюз чи OAuth-провайдер), `cy.origin()` дає змогу симулювати таку взаємодію у тесті.

    - **Безшовна інтеграція:**  
      Можна перемикатися між доменами в одному тесті і перевірити повну юзер-джорні застосунку.

    **Приклад використання `cy.origin()`:**

    Уявіть, ваш додаток потребує авторизації через сторонній сервіс на `https://auth.example.com`, а основний додаток працює на `http://localhost:3000`.

    ```javascript
    // У файлі тесту багатодоменного логіну
    describe('Multidomain Login Test', () => {
      it('має виконати вхід через сторонній auth сервіс', () => {
        // Відвідати головну сторінку додатку
        cy.visit('/login');

        // Клік веде до зовнішнього домену авторизації
        cy.get('[data-testid="login-with-oauth"]').click();

        // Використати cy.origin() для перемикання на домен авторизації
        cy.origin('https://auth.example.com', () => {
          cy.get('[data-testid="auth-username"]').type('externalUser');
          cy.get('[data-testid="auth-password"]').type('externalPass');
          cy.get('[data-testid="auth-submit"]').click();
        });

        // Повернутися на основний домен та перевірити успішний вхід
        cy.url().should('include', '/dashboard');
        cy.get('[data-testid="welcome-message"]').should('contain', 'Welcome');
      });
    });
    ```



### Додаткові приклади коду для багатодоменного тестування

**Приклад: Перемикання між кількома доменами**

Уявіть, ваш тест має відвідати маркетинговий сайт на іншому домені після входу в основний застосунок:

```javascript
describe('Multidomain Navigation', () => {
  it('повинен перейти з основного додатку на маркетинговий сайт', () => {
    cy.visit('/login');
    cy.get('[data-testid="login-with-oauth"]').click();

    cy.origin('https://auth.example.com', () => {
      cy.get('[data-testid="auth-username"]').type('externalUser');
      cy.get('[data-testid="auth-password"]').type('externalPass');
      cy.get('[data-testid="auth-submit"]').click();
    });

    // Після входу користувача відправляють на сторінку на іншому домені
    cy.origin('https://marketing.example.com', () => {
      cy.visit('/special-offers');
      cy.get('[data-testid="offer-banner"]').should('be.visible');
    });
  });
});
```
---

#### **D. Практичні завдання**

1. **Налаштування baseUrl і оновлення тестів:**
   - **Завдання:**  
     Оновіть тести так, щоб використовувався `cy.visit('/')` із налаштованим `baseUrl` у `cypress.config.js`.
   - **Мета:**  
     Тести мають використовувати відносні URL та підтвердити, що встановлено правильний base URL залежно від середовища.

3. **Практика з cy.origin та cy.session:**
   - **Завдання:**  
     Напишіть тест, що переходить на інший домен за допомогою `cy.origin` (імітуйте зовнішню авторизацію).
   - **Мета:**  
     Показати, як обробляти багатодоменно-сценарії та знизити підготовчу складність.

---

#### **E. Приклади команд та конфігурації Cypress**

**Використання baseUrl у тесті:**
```javascript
describe('Home Page Navigation', () => {
  it('має завантажувати сторінку входу з відносним шляхом', () => {
    cy.visit('/login'); // Додається до baseUrl + /login
    cy.get('[data-testid="page-title"]').should('contain', 'Login');
  });
});
```

**Використання cy.origin:**
```javascript
describe('Cross-Origin Login', () => {
  it('має виконувати вхід на зовнішньому домені', () => {
    cy.origin('https://external.example.com', () => {
      cy.get('[data-testid="external-login"]').click();
    });
  });
});
```

---

### **Поширені питання студентів та відповіді**

1. **Q:** *Як baseUrl допомагає спростити наші тести?*  
   **A:** Встановивши baseUrl у конфігурації, ви можете використовувати відносні шляхи в `cy.visit()`. Це робить ваші тести чистішими та простішими для оновлення при зміні середовища.

2. **Q:** *Що таке контексти у Cypress і чому вони корисні?*  
   **A:** Контексти, реалізовані через вкладені `describe()` блоки, дозволяють логічно групувати тести (наприклад, для різних ролей користувачів). Це допомагає підтримувати структуру тест-сьюту, ізоляцію та полегшує супровід та дебаг.

3. **Q:** *Яке призначення cy.origin?*  
   **A:** `cy.origin` дозволяє виконувати команди у контексті іншого домену. Це важливо для тестування взаємодії через домени, наприклад, зовнішню авторизацію.

5. **Q:** *Чи можна перевизначити baseUrl для окремих тестів?*  
   **A:** Хоча baseUrl є глобальним параметром, ви можете перевизначати його у конкретних тестах, використовуючи абсолютний URL у `cy.visit()`. Але краще користуватися глобальним baseUrl для послідовності, якщо на це немає особливої потреби.

6. **Q:** *Які найкращі практики у використанні контекстів у Cypress?*  
   **A:** Організуйте тести через вкладені блоки `describe()` з чіткими назвами. Використовуйте хуки (beforeEach/afterEach) для підготовки або очистки стану у кожному контексті — це забезпечить ізоляцію та підтримуваність тестів.

---

### **Поширена проблема крос-доменних тестів**

```javascript
describe('Cypress lost value', () => {
  var value1
  var value2;
  
  it('10 - перейти та увійти на domain1 і зберегти значення у змінну', () => {
    cy.visit('https://domain1.com');
    cy.loginDomain1().then((value) => {
      value1 = value
    })
    value2 = 100
  });

  it('20 - перейти та увійти на domain2 з використанням value1', () => {
    cy.visit('https://domain2.com');
    cy.log(value2) 
    cy.loginDomain2(value1)
  })
});
```

#### Чому Cypress все скидає при зміні домену?

Причина у **правилах безпеки веб-браузера**:

##### Що відбувається?

Якщо ви робите, наприклад:

```javascript
cy.visit('https://domain1.com');
// деякі дії...
cy.visit('https://domain2.com');
// тест падає або значення змінних втрачаються…
```

Cypress **автоматично скидає увесь браузерний контекст** при зміні origin.

### 🔹 Чому?

Через **політику Same-Origin (SOP)** у браузерах:

* JavaScript з одного origin (`https://domain1.com`) не може напряму взаємодіяти із вмістом іншого origin (`https://domain2.com`).
* Cypress дотримується цієї політики, щоб **захистити цілісність тестів** та уникнути **витоку даних чи scope** через домени.

Коли Cypress фіксує зміну origin:

* **Скидається тестовий iframe**
* Усі **змінні у пам’яті**, DOM, cookies і JavaScript **scope очищаються**
* Це забезпечує ізоляцію та безпечність тесту

---

#### Приклад: Чому змінна `undefined` при зміні домену

```javascript
let token;

it('отримує токен з domain1', () => {
  cy.visit('https://domain1.com');
  cy.getCookie('authToken').then((cookie) => {
    token = cookie.value;
  });
});

it('пробує використати токен на domain2', () => {
  cy.visit('https://domain2.com');
  cy.log(token); // 🔴 тут token буде undefined
});
```

##### Що не так?

* Змінна `token` оголошена **у основній області тесту**.
* Коли Cypress переходить на новий домен — контекст виконання очищується.
* Тому `token` втрачається — Cypress починає "з чистого аркуша".


У Cypress кожен тестовий блок (`it`) виконується ізольовано, тобто змінні, створені в одному тесті, не гарантовано будуть доступні в іншому. Навіть при глобальних змінних, Cypress скидає стан між тестами для уникнення прихованих залежностей. Додатково, команди Cypress асинхронні, тому присвоєння значення перемінній через `.then()` може не бути ще завершеним, або бути скинутим до моменту запуску іншого тесту.

**Основні моменти:**

- **Ізоляція тестів:**  
  Cypress виконує кожен `it`-блок ізольовано, щоб уникнути побічних ефектів. Глобальні змінні не гарантовано зберігаються між тестами.

- **Асинхронність команд:**  
  Колбек з `.then()` у першому тесті присвоює значення, але коли запускається другий тест — ізоляція може все скинути.

- **Best Practice:**  
  Замість глобальних змінних використовуйте `cy.session()` або будуйте ланцюжки команд у межах одного блоку. Якщо треба передати дані далі — використовуйте контекст тесту через закриття (closures) або кастомні таски Cypress.

**Пояснення прикладу:**

```javascript
describe('Cypress lost value', () => {
  var value1;
  
  it('10 - перейти та увійти на domain1 і зберегти значення', () => {
    cy.visit('https://domain1.com');
    cy.loginDomain1().then((value) => {
      value1 = value // value1 присвоюється тут
    });
    value2 = 100 // value1 присвоюється тут
  });

  it('20 - перейти та увійти на domain2 з використанням value1', () => {
    cy.visit('https://domain2.com');
    // Під час запуску тесту value1, value2 будуть undefined через ізоляцію
    cy.log(value2) //-> value2 undefined
    cy.loginDomain2(value1); //-> value1 undefined
  });  
});
```

У другому тесті `value1` є `undefined`, бо:
- **Ізоляція тестів:** Кожен блок `it` ізольований.
- **Асинхронність:** Навіть якщо value1 був присвоєний — він може не зберігатися через асинхронність і очищення стану між тестами.


Розуміння ізоляції тестів та асинхронності команд у Cypress допоможе вам будувати структуровані тести без зовнішніх спільних змінних.


Якщо потрібно поділитися значенням між тестами — особливо між різними доменами — важливо пам’ятати, що Cypress навмисно ізолює кожен блок `it()`. Це забезпечує незалежність тестів, але значення змінних із одного тесту не потрапляють в інший. Ось деякі найкращі практики та рішення для цієї ситуації:

### **Best Practices для спільного стану між тестами**

1. **Тримайте тести незалежними:**  
   Ідеально — кожен тест має бути самостійним. Якщо потрібно передати значення з одного домену на інший, об’єднайте ці дії у один тест.

2. **Об’єднуйте взаємозалежні флоу:**  
   Якщо дві доменні дії — це послідовний флоу користувача (наприклад, логін на domain1 і далі дії на domain2), об’єднуйте це в одному тесті.

4. **Зберігання даних через cy.task():**  
   Використовуйте кастомний таск для збереження даних (у файл чи пам’ять), які можна потім отримати в іншому тесті. Це корисно для обміну даними між тестами, навіть через домени.

#### **Приклади рішень**

##### **Рішення 1: Об’єднання у один тестовий блок**

Якщо флоу від domain1 до domain2 — це один юзерськоий сценарій, об’єднуйте їх:
  
```javascript
describe('Multidomain Login Flow', () => {
  it('логіниться на domain1 і використовує значення на domain2', () => {
    // Крок 1: Відвідати domain1 та отримати значення
    cy.visit('https://domain1.com');
    cy.loginDomain1().then((value) => {
      // value доступне тут
      // Крок 2: перемкнутися на domain2 через cy.origin()
      cy.visit('https://domain2.com');
      cy.origin('https://domain2.com', () => {
        // Вжити отримане значення на domain2
        cy.loginDomain2(value).should('succeed');
      });
    });
  });
});
```

##### **Рішення 2: Використання cy.task() для збереження між тестами**

Якщо об’єднати тести складно — використовуйте кастомний таск для зберігання значення поза контекстом тесту:

1. **Визначте таск у cypress.config.js або окремому файлі:**

```javascript
// У cypress.config.js або у файлі support
module.exports = defineConfig({
  e2e: {
    setupNodeEvents(on, config) {
      let sharedValue; // Сховище у пам’яті

      on('task', {
        saveValue(value) {
          sharedValue = value;
          return null;
        },
        getValue() {
          return sharedValue;
        }
      });
      return config;
    }
  }
});
```

2. **Використання cy.task() у тестах:**

```javascript
describe('Multidomain Flow with Persisted Value', () => {
  it('зберігає значення з domain1', () => {
    cy.visit('https://domain1.com');
    cy.loginDomain1().then((value) => {
      cy.task('saveValue', value);
    });
  });

  it('отримує значення і використовує його на domain2', () => {
    cy.visit('https://domain2.com');
    cy.task('getValue').then((value) => {
      cy.loginDomain2(value).should('succeed');
    });
  });
});
```


##### **Рішення 3: Зберігати у файлі**

1. **Задайте таски в функції `setupNodeEvents`:**

   У `cypress.config.js` (або імпортованому файлі) можна налаштувати кастомні таски для запису/читання значення у файл:

   ```javascript
   const fs = require('fs');
   const path = require('path');

   module.exports = defineConfig({
     e2e: {
       setupNodeEvents(on, config) {
         on('task', {
           writeValue({ filename, value }) {
             const filePath = path.join(__dirname, filename);
             fs.writeFileSync(filePath, JSON.stringify(value));
             return null;
           },
           readValue({ filename }) {
             const filePath = path.join(__dirname, filename);
             if (fs.existsSync(filePath)) {
               const data = fs.readFileSync(filePath, 'utf8');
               return JSON.parse(data);
             }
             return null;
           }
         });
         return config;
       },
       baseUrl: 'http://localhost:3000'
     },
     env: {
       // Перемінні для різних середовищ...
     }
   });
   ```

2. **Використання у тестах:**

   Тепер можна через `cy.task('writeValue', { filename, value })` зберегти значення у одному тесті, та через `cy.task('readValue', { filename })` отримати у іншому.

   **Приклад:**

   ```javascript
   describe('Store and Retrieve Value from File', () => {
     it('має зберегти значення з domain1 у файл', () => {
       cy.visit('https://domain1.com');
       cy.loginDomain1().then((value) => {
         cy.task('writeValue', { filename: 'cypress/sharedValue.json', value });
       });
     });

     it('має отримати значення з файлу і використати на domain2', () => {
       cy.visit('https://domain2.com');
       cy.task('readValue', { filename: 'cypress/sharedValue.json' }).then((value) => {
         cy.loginDomain2(value).should('succeed');
       });
     });
   });
   ```

  ##### **Переваги використання зберігання у файлах:**

  - **Збереження:**  
    Дані залишаються навіть якщо тести виконуються у різних процесах чи сесіях.
    
  - **Дебаг:**  
    Можна вручну переглянути файл, щоб побачити збережені дані.

  - **Декуплінг:**  
    Тести не залежать від пам’яті процесу; можна ділитися між різними запусками тестів.

  ### **Недоліки:**

  - **Витрати на I/O:**  
    Операції з файлами повільніші за пам’ять.
    
  - **Складність:**  
    Потрібно керувати очищенням файлів та ускладнюється логіка.

  - **Потенційна флейкість:**  
    Якщо тести паралельні і пишуть/читають один файл — можливі race conditions. Необхідна ізоляція і очищення.

  ### **Best Practices:**

  - **Унікальні імена файлів:**  
    Призначайте унікальні файли для кожного набору тестів.
    
  - **Очищення:**  
    Видаляйте або скидайте файл після виконання тесту, щоб уникнути застарілих даних.
    
  - **Обробка помилок:**  
    Обробляйте ситуації (наприклад, файл не знайдено), щоб тести завершувались коректно.

  Зберігання у файлах через `cy.task()` — надійне рішення для передачі значень між тестами, особливо коли інші методи (глобальні змінні чи `cy.session()`) не підходять. Це особливо корисно у багатодоменних чи мульти-сесійних сценаріях, де треба ділитися даними за межами одного тесту.