## **Урок 9: Робота з фікстурами та керування тестовими даними**

#### **A. Використання фікстур**

##### **Чому важливе керування даними?**

1. **Послідовність і надійність:**
   - **Централізовані тестові дані:** Зберігання тестових даних у фікстурах або зовнішніх файлах забезпечує, що тести виконуються із використанням послідовних і контрольованих наборів даних. Це зменшує ризик нестабільних тестів через змінні дані.
   - **Відтворюваність результатів:** При гарному управлінні даними кожен запуск тесту є відтворюваним, що полегшує діагностику проблем у разі їх виникнення.

2. **Обслуговуваність:**
   - **Відокремлення даних і логіки:** Відділення тестових даних від тестових скриптів спрощує оновлення або зміну вхідних даних без модифікації основного тестового коду.
   - **Легке оновлення:** Коли моделі даних застосунку змінюються, потрібно оновити лише фікстури або файли даних, а не кожен тест, який використовує ці дані.

3. **Масштабованість:**
   - **Обробка кількох сценаріїв:** Керування даними дозволяє легко параметризувати тести, тож одна й та ж логіка тесту може виконуватися з різними наборами даних. Це підтримує data-driven тестування і допомагає охопити більше крайових випадків.
   - **Спрощена організація тестів:** Структуровані дані забезпечують кращу організацію, дозволяючи групувати пов’язані тести та запускати їх підмножини за потреби.

4. **Ефективність автоматизації:**
   - **Мокування зовнішніх сервісів:** Для API-тестування фікстури допомагають імітувати відповіді бекенду, роблячи тести незалежними від живих зовнішніх систем.
   - **Динамічна генерація даних:** Інтеграція інструментів типу Faker дозволяє генерувати унікальні дані "на льоту", щоб уникати конфліктів (наприклад, дублювання акаунтів) та забезпечити виконання кожного тесту у свіжому контексті.


1. **Створення файлів фікстур (JSON):**
   - **Визначення:**  
     Фікстури — це зовнішні дані (зазвичай у форматі JSON), які зберігають тестові дані окремо від коду тесту.
   - **Призначення:**  
     - Організувати й повторно використовувати тестові дані.  
     - Полегшити обслуговування й оновлення без зміни тестових скриптів.
   - **Приклад фікстури:**  
     Створіть файл `users.json` у папці `cypress/fixtures`:
     ```json
     [
       { "username": "demoUser", "password": "demoPass", "role": "admin" },
       { "username": "userOne", "password": "passOne", "role": "user" }
     ]
     ```

2. **Завантаження даних із фікстури у тестах (cy.fixture()):**
   - **Використання:**  
     `cy.fixture()` завантажує дані з фікстури, які потім можна використати у вашому тесті.
   - **Приклад:**
     ```javascript
     cy.fixture('users').then((users) => {
       // Використання даних із фікстури (наприклад, ітерувати користувачів для тестування входу)
       expect(users).to.have.length.above(0);
     });
     ```

3. **Структурування фікстур для повторного використання:**
   - **Найкращі практики:**  
     - Організуйте фікстури у логічних файлах (наприклад, окремі файли для користувачів, продуктів, налаштувань).  
     - Використовуйте зрозумілі й описові імена файлів.  
     - Якщо дані ієрархічні, вкладені об’єкти відповідним чином.
   - **Порада:**  
     Структуруйте фікстури так, щоб вони відображали різні тестові сценарії (валідні дані, невалідні дані, крайові випадки).

---


#### **B. Робота з динамічними даними**

1. **Генерація випадкових даних для тестів:**
   - **Призначення:**  
     - Перевірити, як додаток обробляє непередбачувані або унікальні введення.  
     - Запобігти збігу даних у тестах, які можуть виконуватися багаторазово.
   - **Підхід:**  
     Використовуйте JavaScript-функції або бібліотеки (наприклад, Faker.js) для генерації випадкових рядків, чисел, дат тощо.
   - **Приклад:**
     ```javascript
     function getRandomString(length) {
       const chars = 'abcdefghijklmnopqrstuvwxyz';
       let result = '';
       for (let i = 0; i < length; i++) {
         result += chars.charAt(Math.floor(Math.random() * chars.length));
       }
       return result;
     }

     const randomUsername = `user_${getRandomString(5)}`;
     cy.log(randomUsername);
     ```


### **Чому важливо використовувати Faker?**

1. **Генерація унікальних, реалістичних тестових даних:**
   - **Запобігання збігам:**  
     Faker генерує випадкові, реалістичні дані (наприклад імена, електронні адреси, адреси), що гарантує відсутність конфліктів, як-от дублювання імен користувачів.
   - **Реалізм:**  
     Тестові дані, які наближені до реальних, точніше імітують сценарії користувачів.

2. **Динамічні дані для параметризації:**
   - **Data-Driven тести:**  
     За допомогою Faker тести можуть динамічно генерувати вхідні дані для кожного запуску, підтримуючи сценарії для одної й тієї ж логіки з різними введеннями.
   - **Масштабованість:**  
     Коли ваш набір тестів зростає, Faker дозволяє легко генерувати величезні об’єми тестових даних без ручного підтримування численних статичних файлів.

3. **Покращена ізоляція тестів:**
   - **Незалежні запуски тестів:**  
     Завдяки унікальним даним, які генеруються динамічно, тести менше впливають один на одного. Це особливо важливо в CI-середовищі, де тести можуть виконуватись паралельно.

4. **Зручність використання:**
   - **Простий API:**  
     API Faker простий і дозволяє генерувати різні види даних всього кількома рядками коду.
   - **Інтеграція:**  
     Добре працює з Cypress; ви можете викликати функції Faker у своїх тестових скриптах для генерації даних під час виконання тестів.

**Приклад використання Faker:**

```javascript
// Встановіть faker командою: npm install --save-dev @faker-js/faker
import { faker } from '@faker-js/faker';

const randomUsername = faker.internet.userName();
const randomEmail = faker.internet.email();

cy.log(`Generated Username: ${randomUsername}`);
cy.log(`Generated Email: ${randomEmail}`);

// Використайте ці значення у тесті, наприклад, для створення нового користувача.
cy.get('[data-testid="username-input"]').type(randomUsername);
cy.get('[data-testid="email-input"]').type(randomEmail);
```

2. **Параметризація тестів різними наборами даних:**
   - **Використання:**  
     Запуск тієї ж логіки тесту з кількома наборами даних із фікстур або згенерованих динамічно.
   - **Приклад:**  
     Ітерування масиву користувачів (з фікстури) для запуску тестів авторизації:
     ```javascript
     cy.fixture('users').then((users) => {
       users.forEach((user) => {
         cy.get('[data-testid="username-input"]').clear().type(user.username);
         cy.get('[data-testid="password-input"]').clear().type(user.password);
         cy.get('[data-testid="login-button"]').click();
         // Додавайте тут перевірки згідно з очікуваними результатами
       });
     });
     ```

---


### **2. Практичні завдання**

1. **Створення та використання фікстур:**
   - **Завдання:**  
     Створіть JSON-файл (наприклад, `users.json`), що містить декілька об’єктів користувачів.  
     Напишіть Cypress-тест, який завантажує цю фікстуру та перевіряє, що масив користувачів містить валідні дані.

2. **Динамічна генерація даних:**
   - **Завдання:**  
     Напишіть утилітарну функцію, яка генерує випадкові дані користувача (наприклад, ім'я користувача, email).  
     Використайте ці динамічні дані в тесті для створення нового користувача та валідації процесу.

3. **Параметризація тесту:**
   - **Завдання:**  
     Використайте файл фікстури, щоб запустити однаковий тест авторизації для кількох користувачів.  
     Перевірте, що додаток правильно реагує для кожної користувацької ситуації.

---

### **3. Корисні ресурси**

- **Документація щодо фікстур Cypress:**  
  [Cypress Fixtures](https://docs.cypress.io/api/commands/fixture)
- **Зразки фікстур і приклади тестових даних:**  
  Дивіться приклади на GitHub чи у документації Cypress для практичного використання.
- **Бібліотеки динамічних даних:**  
  Розгляньте використання бібліотек типу [Faker.js](https://www.npmjs.com/package/faker) для генерації випадкових тестових даних.
