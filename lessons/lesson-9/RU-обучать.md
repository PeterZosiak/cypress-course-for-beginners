## **Урок 9: Работа с фикстурами и управлением тестовыми данными**

#### **A. Использование фикстур**

##### **Почему важно управление данными?**

1. **Согласованность и надежность:**
   - **Централизованные тестовые данные:** Хранение тестовых данных в фикстурах или внешних файлах обеспечивает запуск тестов на неизменяемых и контролируемых наборах данных. Это снижает риск нестабильных (“flaky”) тестов из-за меняющихся данных.
   - **Повторяемые результаты:** При хорошо организованных данных каждый запуск теста воспроизводим, что облегчает диагностику проблем при сбоях.

2. **Поддерживаемость:**
   - **Разделение данных и логики:** Благодаря отделению тестовых данных от тестовых скриптов обновление или изменение входных данных происходит проще и не требует правки основного тестового кода.
   - **Упрощённые обновления:** Когда меняются модели данных приложения, нужно обновлять только фикстуры или файлы с данными, а не каждый тест, использующий эти данные.

3. **Масштабируемость:**
   - **Обработка нескольких сценариев:** Управление данными позволяет легко параметризовать тесты, чтобы одна и та же логика теста запускалась с разными наборами данных. Это поддерживает data-driven тестирование и помогает охватить больше граничных случаев.
   - **Упрощённая организация тестов:** Структурированные данные обеспечивают лучшую организацию, позволяя группировать связанные тесты и запускать подмножества по необходимости.

4. **Эффективность автоматизации:**
   - **Мок внешних сервисов:** Для тестирования API фикстуры помогают эмулировать ответы бэкенда, делая тесты независимыми от “живых” внешних систем.
   - **Динамическая генерация данных:** Интеграция инструментов вроде Faker позволяет генерировать уникальные данные на лету, избегая конфликтов (например, дублирующихся пользователей) и гарантируя, что каждый тест запускается в новом контексте.

1. **Создание файлов фикстур (JSON):**
   - **Определение:**  
     Фикстуры — это внешние файлы с данными (чаще всего в формате JSON), в которых тестовые данные хранятся отдельно от кода тестов.
   - **Назначение:**  
     - Организовать и многократно использовать тестовые данные.
     - Облегчить поддержку и обновление данных без необходимости менять тестовые скрипты.
   - **Пример фикстуры:**  
     Создайте файл `users.json` в папке `cypress/fixtures`:
     ```json
     [
       { "username": "demoUser", "password": "demoPass", "role": "admin" },
       { "username": "userOne", "password": "passOne", "role": "user" }
     ]
     ```

2. **Загрузка данных фикстур в тестах (cy.fixture()):**
   - **Использование:**  
     `cy.fixture()` загружает данные из фикстуры, которые можно использовать в тесте.
   - **Пример:**
     ```javascript
     cy.fixture('users').then((users) => {
       // Используйте данные фикстуры (например, итерируйте пользователей для выполнения теста входа)
       expect(users).to.have.length.above(0);
     });
     ```

3. **Структурирование фикстур для повторного использования:**
   - **Рекомендации:**  
     - Организуйте фикстуры по логическим файлам (например, отдельные файлы для пользователей, товаров, настроек).
     - Используйте понятные и описательные имена файлов.
     - Для иерархических данных организуйте объекты соответствующим образом.
   - **Совет:**  
     Организуйте фикстуры так, чтобы отражать разные сценарии тестирования (валидные данные, невалидные данные, граничные случаи).

---

#### **B. Работа с динамическими данными**

1. **Генерация случайных данных для тестов:**
   - **Назначение:**  
     - Проверить, как приложение обрабатывает непредсказуемые или уникальные входные данные.
     - Предотвратить конфликты данных в тестах, которые могут запускаться многократно.
   - **Подход:**  
     Используйте функции JavaScript или библиотеки (например, Faker.js) для генерации случайных строк, чисел, дат и т.п.
   - **Пример:**
     ```javascript
     function getRandomString(length) {
       const chars = 'abcdefghijklmnopqrstuvwxyz';
       let result = '';
       for (let i = 0; i < length; i++) {
         result += chars.charAt(Math.floor(Math.random() * chars.length));
       }
       return result;
     }

     const randomUsername = `user_${getRandomString(5)}`;
     cy.log(randomUsername);
     ```

### **Почему важно использовать Faker?**

1. **Генерация уникальных и реалистичных тестовых данных:**
   - **Избежание коллизий:**  
     Faker генерирует случайные и реалистичные данные (например, имена, e-mail, адреса), что предотвращает конфликты, такие как дублирующиеся имена пользователей.
   - **Реалистичность:**  
     Тестовые данные, максимально похожие на реальные, позволяют точнее симулировать пользовательские сценарии.

2. **Динамические данные для параметризации:**
   - **Data-driven тесты:**  
     При использовании Faker можно динамически генерировать входные данные для каждого запуска теста, поддерживая сценарии, когда одна и та же логика теста применяется к разным входным данным.
   - **Масштабируемость:**  
     По мере роста набора тестов Faker позволяет легко создавать большое количество тестовых данных без ручной поддержки больших статических файлов.

3. **Улучшенная изоляция тестов:**
   - **Независимые запуски тестов:**  
     С уникальными данными, генерируемыми “на лету”, тесты с меньшей вероятностью будут влиять друг на друга. Особенно важно для CI-сред с параллельным выполнением тестов.

4. **Простота использования:**
   - **Простой API:**  
     API у Faker интуитивно понятный, можно генерировать разные виды данных за несколько строк кода.
   - **Интеграция:**  
     Хорошо работает с Cypress — можно вызывать функции Faker в тестовых скриптах для генерации данных во время выполнения тестов.

**Пример использования Faker:**

```javascript
// Установите faker командой: npm install --save-dev @faker-js/faker
import { faker } from '@faker-js/faker';

const randomUsername = faker.internet.userName();
const randomEmail = faker.internet.email();

cy.log(`Generated Username: ${randomUsername}`);
cy.log(`Generated Email: ${randomEmail}`);

// Используйте эти значения в тесте, например, для создания нового пользователя.
cy.get('[data-testid="username-input"]').type(randomUsername);
cy.get('[data-testid="email-input"]').type(randomEmail);
```

2. **Параметризация тестов с разными наборами данных:**
   - **Использование:**  
     Запуск одной и той же логики теста с несколькими наборами данных из фикстур или сгенерированных динамически.
   - **Пример:**  
     Итерация по массиву пользователей (из фикстуры) для выполнения тестов входа:
     ```javascript
     cy.fixture('users').then((users) => {
       users.forEach((user) => {
         cy.get('[data-testid="username-input"]').clear().type(user.username);
         cy.get('[data-testid="password-input"]').clear().type(user.password);
         cy.get('[data-testid="login-button"]').click();
         // Добавьте здесь проверки на ожидаемые результаты
       });
     });
     ```

---

### **2. Практические задания**

1. **Создание и использование фикстуры:**
   - **Задание:**  
     Создайте JSON-файл (например, `users.json`), содержащий несколько объектов пользователей.  
     Напишите тест на Cypress, который загрузит эту фикстуру и проверит, что массив пользователей содержит валидные данные.

2. **Генерация динамических данных:**
   - **Задание:**  
     Напишите утилитную функцию для генерации случайных данных пользователя (например, логин, e-mail).  
     Используйте эти данные в тесте для создания нового пользователя и проверьте процесс.

3. **Параметризация теста:**
   - **Задание:**  
     Используйте файл с фикстурой для запуска одного и того же теста входа для разных пользователей.  
     Проверьте, что приложение корректно реагирует на каждый пользовательский сценарий.

---

### **3. Ресурсы**

- **Документация по фикстурам Cypress:**  
  [Cypress Fixtures](https://docs.cypress.io/api/commands/fixture)
- **Примеры файлов фикстур и тестовых данных:**  
  Изучайте примеры на GitHub или в документации Cypress для практического применения.
- **Библиотеки для динамических данных:**  
  Рассмотрите использование библиотек типа [Faker.js](https://www.npmjs.com/package/faker) для генерации случайных тестовых данных.