## **Урок 15: Сетевые запросы и базовое тестирование API с помощью Cypress**

### **Цели**

- Научиться перехватывать и изменять сетевые запросы с использованием Cypress.
- Понять, как подменять ответы для создания стабильных, контролируемых сред тестирования.
- Выполнять базовое тестирование API, отправляя запросы и проверяя ответы.
- Комбинировать UI- и API-тесты для обеспечения широкого охвата тестирования.

---

### **Структура содержимого**

#### **Что такое API?**

**Определение:**  
API (Application Programming Interface, программный интерфейс приложения) — это набор правил и протоколов, позволяющий различным программным приложениям обмениваться данными между собой. API определяет методы и форматы данных, которые могут использоваться для запроса и обмена информацией.

**Ключевые моменты:**
- **Интерфейс для обмена:**  
  Позволяет одной программе взаимодействовать с другой без необходимости знать их внутреннее устройство.
- **Типы:**  
  - **Веб-API:** Используют HTTP/HTTPS для обмена между клиентом и сервером.
  - **API библиотек/SDK:** Предоставляют функции для работы с библиотеками или фреймворками.
- **Использование:**  
  API необходимы для интеграции систем, получения данных из удаленных сервисов или подключения сторонних интеграций.

#### **Что такое Backend и Frontend?**

**Frontend:**
- **Определение:**  
  Frontend — это часть приложения, с которой взаимодействует пользователь напрямую. Включает пользовательский интерфейс (UI), код на HTML, CSS и JavaScript, выполняемый в браузере.
- **Фокус в тестировании:**  
  Cypress в первую очередь предназначен для end-to-end тестирования frontend, имитируя действия пользователя и проверяя поведение UI.

**Backend:**
- **Определение:**  
  Backend — это серверная часть приложения. Отвечает за бизнес-логику, работу с базой данных, аутентификацию и API эндпоинты.
- **Аспект тестирования:**  
  Хотя Cypress преимущественно используется для тестирования frontend, с его помощью также возможно тестировать backend API — отправлять HTTP-запросы (`cy.request()`) и подменять сетевые вызовы с помощью `cy.intercept()`.

#### **Что такое HTTP-запрос и HTTP-ответ?**

**HTTP-запрос:**
- **Определение:**  
  HTTP-запрос — это сообщение, отправленное клиентом (например, браузером) на сервер с целью получения ресурса или выполнения действия.
- **Компоненты:**  
  - **Метод:** GET, POST, PUT, DELETE и т.д.
  - **URL:** Адрес (энндпоинт), к которому обращается клиент.
  - **Заголовки:** Пары "ключ-значение" с дополнительной информацией (например, Content-Type, Authorization).
  - **Тело:** Данные, передаваемые с запросом (чаще всего в POST или PUT).

**HTTP-ответ:**
- **Определение:**  
  HTTP-ответ — это сообщение, отправляемое сервером обратно клиенту после обработки HTTP-запроса.
- **Компоненты:**  
  - **Код статуса:** Числовой код результата (например, 200 — успешно, 404 — не найдено).
  - **Заголовки:** Метаинформация о ответе (например, Content-Type, Cache-Control).
  - **Тело:** Фактические данные, возвращаемые сервером (HTML, JSON и т.д.).


#### **HTTP-заголовки**

**Определение:**  
- **HTTP-заголовки** — это пары “ключ-значение”, передаваемые как часть HTTP-запроса или ответа. Они содержат метаинформацию о запросе или ответе, например, тип контента, кодировку, политики кэширования, токены аутентификации и др.

**Назначение и функции:**
- **Согласование формата данных (Content Negotiation):**  
  Заголовки типа `Accept` и `Content-Type` сообщают, в каком формате (JSON, XML, HTML) клиент может принимать данные, либо формате тела запроса.
- **Авторизация и безопасность:**  
  Заголовки, например, `Authorization` (Bearer-токен), используются для аутентификации и авторизации клиента.
- **Директивы кэширования:**  
  Заголовки `Cache-Control`, `ETag`, `Expires` управляют поведением кэша у клиента и прокси.
- **Информация о клиенте и сервере:**  
  Заголовок `User-Agent` (информация о клиенте), `Server` (серверная информация) — указывают данные об источнике или адресате.
- **Пользовательские заголовки:**  
  Приложения могут использовать кастомные заголовки (часто начинающиеся на `X-` или `Custom-`) для передачи дополнительной нестандартной информации.

**Пример в запросе:**
```http
GET /api/users HTTP/1.1
Host: example.com
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR...
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
```

**Пример в ответе:**
```http
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-cache, no-store, must-revalidate
Expires: 0
Content-Length: 123
```

**Важность для тестирования:**
- При тестировании Cypress может изменять заголовки (например, добавлять токен авторизации) с помощью `cy.intercept()`.
- Проверка заголовков важна для того, чтобы убедиться: приложение корректно и безопасно обменивается данными с клиентом.

#### **HTTP тело (Body)**

**Определение:**  
- **HTTP Body (тело запроса/ответа)** — это часть HTTP-запроса или ответа, содержащая фактические передаваемые данные. В запросах это могут быть данные формы, JSON, XML или бинарные данные, а в ответах обычно содержится запрошенный ресурс (например, HTML-страница, JSON-объект или файл).

**Назначение и функции:**
- **Передача данных:**  
  В POST, PUT или PATCH запросах тело содержит отправляемую на сервер информацию (например, отправка формы, загрузка файла).
- **Представление ресурса:**  
  В GET-запросах тело ответа содержит представление ресурса, например, HTML-страницу или JSON из API.
- **Согласование формата данных:**  
  Формат тела часто определяется заголовком `Content-Type`, что гарантирует правильное интерпретирование данных клиентом и сервером.

**Пример в теле запроса:**
- **POST-запрос (JSON):**
  ```json
  {
    "username": "demoUser",
    "password": "demoPass"
  }
  ```

**Пример в теле ответа:**
- **GET-запрос (JSON):**
  ```json
  [
    { "id": 1, "name": "Alice" },
    { "id": 2, "name": "Bob" }
  ]
  ```

**Важность для тестирования:**
- При тестировании API с помощью `cy.request()` или при подмене ответов с помощью `cy.intercept()` важно проверять тело ответа на соответствие ожидаемым данным.
- Также важно посылать корректные данные в теле запроса, чтобы убедиться, что приложение правильно их обрабатывает.

#### **Что такое MOCK?**

**Определение:**  
Mocking — это практика имитации ответов API или других внешних сервисов путём замены их на заранее подготовленные, контролируемые данные. Это позволяет:
- **Изолировать тесты:**  
  Не зависеть от доступности или поведения внешних систем.
- **Создать стабильные данные:**  
  Обеспечить одинаковые ответы для предсказуемого исхода тестов.
- **Ускорить тесты:**  
  Исключить задержки и нестабильность, связанные с внешними сервисами.

---

#### **A. Базовое тестирование API**

1. **Отправка API-запросов в Cypress:**
   - **Использование `cy.request()`:**
     - **Определение:**  
       `cy.request()` — отправляет HTTP-запрос непосредственно из теста. Идеально для тестирования API-эндпоинтов без работы с UI.
     - **Пример:**
       ```javascript
       cy.request('GET', '/api/users').then((response) => {
         // Проверить ответ здесь
       });
       ```

2. **Проверка ответа API:**
   - **Код статуса:**  
     Проверить, что статус ответа соответствует ожиданию (например, 200 — успех).
     ```javascript
     cy.request('/api/users').its('status').should('eq', 200);
     ```
   - **Тело ответа:**  
     Проверять структуру и содержимое ответа с помощью утверждений.
     ```javascript
     cy.request('/api/users').then((response) => {
       expect(response.body).to.be.an('array');
       expect(response.body[0]).to.have.property('name', 'Alice');
     });
     ```

3. **Комбинирование UI- и API-тестов:**
   - **Вариант использования:**  
     Убедиться, что UI отображает те же данные, что возвращает API-запрос. Например, получить данные пользователя через `cy.request()`, затем убедиться, что они отображаются в интерфейсе.
     ```javascript
     cy.request('/api/users').then((apiResponse) => {
       cy.visit('/users');
       apiResponse.body.forEach((user, index) => {
         cy.get(`[data-testid="user-${index}"]`).should('contain', user.name);
       });
     });
     ```

---

#### **B. Перехват сетевых запросов**

1. **Применение `cy.intercept()`:**
   - **Определение:**  
     `cy.intercept()` — команда Cypress, позволяющая прослушивать, перехватывать и изменять HTTP-запросы и ответы. Важно для изоляции тестов от зависимостей backend и для достижения предсказуемости.

    **Основные сценарии:**
    - **“Шпионаж” за запросами:**  
      Перехватывать и анализировать сетевые запросы, чтобы убедиться, что они отправляются как ожидалось.
    - **Подмена (stubbing) ответов:**  
      Заменять ответы контролируемыми (mock) данными с целью изоляции от backend.
    - **Модификация запросов/ответов:**  
      Изменять заголовки, тело или другие свойства до попадания их в приложение.

    **Почему это важно:**
    - **Изоляция:**  
      Обеспечивает независимость тестов от переменчивости бэкенда, делая тесты детерминированными.
    - **Управление:**  
      Позволяет симулировать различные сценарии (успешные, неудачные, задержки) путём настройки ответов.
    - **Гибкость:**  
      Можно проверить обработку ошибок, аутентификацию и другое без изменения backend.

   - **Базовый синтаксис:**
     ```javascript
     cy.intercept(method, url, response);
     ```
     - **method:** HTTP-метод (GET, POST и т.д.).
     - **url:** URL-эндпоинт (может быть шаблоном или regex).
     - **response:** Необязательный объект для подмены ответа.
   - **Пример:**
     ```javascript
     // Перехватить GET-запросы к "/api/users"
     cy.intercept('GET', '/api/users').as('getUsers');
     ```
   - **Подмена ответов:**  
     Вместо обращения к реальному backend, можно замокать ответ.
     ```javascript
     cy.intercept('GET', '/api/users', {
       statusCode: 200,
       body: [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }],
     }).as('getUsers');
     ```

      **Пример кода – подмена ответа:**
      ```javascript
      cy.intercept('GET', '/api/users', {
        statusCode: 200,
        body: [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }],
      }).as('getUsers');

      cy.visit('/users');
      cy.wait('@getUsers').its('response.statusCode').should('eq', 200);
      ```

      **Пример модификации HTTP-заголовков:**
      ```javascript
      cy.intercept(
        {
          method: 'GET',
          url: '/api/secure-data'
        },
        (req) => {
          // Изменить заголовки до отправки запроса
          req.headers['Authorization'] = 'Bearer my-secret-token';
        }
      ).as('secureData');

      cy.visit('/secure');
      cy.wait('@secureData');
      ```

      ##### **6. Что такое .as() в Cypress?**

      **Определение:**  
      Команда `.as()` в Cypress позволяет присвоить псевдоним (alias) запросу, элементу или любому цепочечному объекту. Этот алиас можно использовать позднее в тесте для обращения к этому же объекту или запросу, что делает тесты более читаемыми и переиспользуемыми.

      **Пример использования:**
      ```javascript
      // Присвоить псевдоним перехваченному сетевому запросу
      cy.intercept('GET', '/api/users').as('getUsers');
      cy.visit('/users');
      cy.wait('@getUsers').then((interception) => {
        // Можно делать утверждения о перехваченном запросе
        expect(interception.response.statusCode).to.eq(200);
      });

      // Присвоить псевдоним DOM-элементу
      cy.get('[data-testid="login-button"]').as('loginButton');
      cy.get('@loginButton').click();
      ```

      **Преимущества:**
      - **Читаемость:**  
        Алиасы делают шаги теста более понятными.
      - **Переиспользуемость:**  
        Можно использовать один и тот же псевдоним в нескольких утверждениях или действиях.

---

#### **C. Лучшие практики**

1. **Изоляция тестов с помощью подмены ответов:**
   - Подменяйте сетевые ответы командой `cy.intercept()`, чтобы тесты не зависели от backend.
   - Это снижает флак (нестабильность), вызванный сетевыми сбоями или ошибками backend.

2. **Детерминированные тесты:**
   - Используйте фиксированные, предсказуемые данные для подмен.
   - Не полагайтесь на внешние сервисы, чтобы результаты тестов всегда были одинаковыми.

3. **Комбинирование UI- и API-тестов:**
   - Проверяйте, что UI-элементы верно отображают данные, возвращаемые API.
   - Используйте API-тесты для проверки логики на стороне сервера, а UI-тесты — для логики отображения.

4. **Ясное применение алиасов и логов:**
   - Давайте перехваченным запросам псевдонимы (например, `.as('getUsers')`), чтобы сделать тесты нагляднее.
   - Используйте логи (`cy.log()`) для отладки сетевых проблем в случае падения тестов.

---

#### **D. Другие JS-фреймворки и инструменты, подходящие для тестирования API**

Хотя Cypress отлично подходит для end-to-end и API-тестирования, существуют и другие инструменты:
  
- **Postman/Newman:**  
  Postman — популярный инструмент для тестирования API, а Newman — его CLI-версия. Удобен для запуска API-тестов в CI/CD.
  
- **Jest с Supertest:**  
  Для юнит- и интеграционного тестирования API можно использовать Jest в связке с Supertest — позволяет писать выразительные тесты, отправляющие HTTP-запросы к вашему backend.
  
- **Mocha/Chai с Axios или Request:**  
  Эти библиотеки можно применять для написания API-тестов вне браузера, особенно если нужно проверить backend-функциональность.
  
- **Puppeteer или Playwright:**  
  Хотя эти инструменты обычно применяют для браузерной автоматизации, они также поддерживают перехват сетевых запросов и API-тестирование.

### **E. Практические задания**

1. **Перехват и подмена сетевых запросов:**
   - Напишите тест, который перехватывает GET-запрос к `/api/users` и возвращает кастомный ответ.
   - Проверьте, что приложение корректно отображает замоканные данные.

2. **Базовое тестирование API:**
   - Используйте `cy.request()` для отправки запроса к API.
   - Проверьте статус ответа, заголовки и тело.

3. **Комбинирование UI- и API-тестов:**
   - Придумайте тест, который получает данные через `cy.request()`, затем переходит на UI-страницу и сравнивает отображаемые данные с API-ответом.

4. **Тестирование мультдоменов с cy.origin:**
   - Напишите тест с переходом на внешний домен (или его имитацию) и проверьте определённые элементы или ответ API.

5. **Управление сессиями через cy.session:**
   - Напишите тесты с использованием `cy.session()` для кеширования состояния авторизации и убедитесь, что последующие тесты используют кэш, сокращая время подготовки.

---

### **F. Ресурсы**

- **Документация по сетевым запросам Cypress:**  
  [Cypress Intercept Documentation](https://docs.cypress.io/api/commands/intercept)
- **Примеры тестирования API с Cypress:**  
  Ищите примеры использования `cy.request()` на GitHub.
- **Мультидоменное тестирование Cypress:**  
  [cy.origin Documentation](https://docs.cypress.io/api/commands/origin)
- **Сессии Cypress:**  
  [cy.session Documentation](https://docs.cypress.io/api/commands/session)

---

### **Возможные вопросы учеников и ответы**

1. **В:** *Зачем подменять сетевые запросы в тестах?*  
   **О:** Подмена запросов позволяет изолировать тесты от изменений на backend и сетевых проблем, обеспечивая запуск с предсказуемыми и стабильными тестовыми данными.

2. **В:** *Чем отличается cy.request() от cy.intercept()?*  
   **О:** `cy.request()` используется для отправки HTTP-запросов напрямую из теста, что удобно для проверки API. `cy.intercept()` позволяет “шпионить” или подменять сетевые запросы, которые приложение делает во время исполнения теста.

5. **В:** *Можно ли совмещать API- и UI-тесты в одном наборе?*  
   **О:** Да, комбинированные UI- и API-тесты дают полный охват — одновременно проверяя корректность данных на backend и их отображение на frontend. Например, через `cy.request()` можно получить данные и затем проверить их отображение в UI.

---

Ниже приведено подробное объяснение HTTP-заголовков и HTTP-тела:

---

---

### **Резюме**

- **HTTP-заголовки:**  
  Задают метаданные запроса или ответа (тип контента, кэширование, авторизация и др.). Критичны для корректной интерпретации данных.
  
- **HTTP-тело:**  
  Содержит реальные передаваемые данные (JSON, HTML, файлы и т.д.). Это основное содержимое HTTP-сообщения.

Понимание и HTTP-заголовков, и тела HTTP-сообщений важно при написании API-тестов, т.к. позволяет удостовериться не только в правильности отправки и получения данных, но и в корректном контексте их обработки — с нужным типом контента, авторизацией и сопутствующей информацией.