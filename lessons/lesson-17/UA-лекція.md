## **Урок 17: Реальні проблеми та рішення Cypress – Приклади з практичного світу**

### **Цілі уроку**

- Визначити найпоширеніші труднощі при використанні Cypress для end-to-end тестування у реальних застосунках.
- Надати практичні рішення та стратегії роботи з динамічним контентом, асинхронною поведінкою, нестабільними тестами та складними інтеракціями.
- Поділитися найкращими практиками щодо написання підтримуваних, масштабованих і надійних тестів.
- Представити реальні кейс-стаді та приклади, а також провести практичні вправи з діагностики та рефакторингу проблемних тестів.

---

### **Структура уроку**

#### **А. Поширені проблеми Cypress**

1. **Робота з динамічним контентом та асинхронною поведінкою**
   - **Проблема:**  
     Багато вебзастосунків оновлюють інтерфейс динамічно, через що елементи бувають недоступними для тесту у потрібний момент.
   - **Виклики:**  
     - Очікування появи елементів.
     - Переконання, що асинхронні API-запити й анімації завершені до виконання ассертів.
     - Вплив непослідовних станів елементів.

2. **Робота з нестабільними тестами та забезпечення надійності**
   - **Проблема:**  
     Нестабільні тести (flaky tests) інколи проходять, інколи — ні, без змін у коді, часто через таймінг, мережеві затримки чи нестійкі селектори.
   - **Виклики:**  
     - Непослідовний рендеринг елементів у часі.
     - Тимчасові мережеві умови.
     - Відмінності середовища локально й у CI.

3. **Тестування складних інтеракцій та додатків зі станом**
   - **Проблема:**  
     Застосунки зі складними сценаріями, багатослівними станами чи вкладеними компонентами складно тестувати надійно.
   - **Виклики:**  
     - Моделювання багатокрокових дій (наприклад, drag-and-drop, вкладені модальні вікна).
     - Підтримка стану застосунку між тестами.
     - Робота з інтеракціями, що залежать від кількох джерел даних чи відповідей API.

---

#### **B. Практичні рішення та стратегії**

1. **Ефективні стратегії очікування**
   - **cy.wait():**  
     Використовуйте `cy.wait()` для затримки виконання на фіксований час за потреби.  
     **Приклад:**  
     ```javascript
     cy.wait(1000); // Зачекати 1 секунду
     ```
   - **Розумні ассерти:**  
     Використовуйте механізм автоматичного повтору Cypress через ассерт стану або наявності елементів.  
     **Приклад:**  
     ```javascript
     cy.get('[data-testid="dynamic-element"]').should('be.visible');
     ```
   - **Кастомне очікування з cy.waitUntil:**  
     Використовуйте плагін `cypress-wait-until`, щоб дочекатися виконання умови.  
     **Приклад:**  
     ```javascript
     cy.waitUntil(() => cy.get('[data-testid="status"]').should('contain', 'Ready'));
     ```

   - **Чому уникати явного `cy.wait()`**
    **1. Крихкість тестів і непередбачуваність:**

    - **Фіксовані затримки — випадкові:**  
      Явне очікування фіксованого часу (наприклад, `cy.wait(2000)`) передбачає, що застосунок завжди буде готовий після цього інтервалу. У реальності мережеві затримки, час відповіді сервера або рендер клієнта можуть змінюватися. Це призводить до нестабільних тестів.

    - **Витрачений час:**  
      Фіксовані затримки подовжують час виконання тесту, навіть якщо додаток готовий раніше. Наприклад, якщо елемент з’являється за 500 мс, але ви чекаєте 2000 мс — це марна трата часу.

    **2. Кращі альтернативи:**

    - **Timeout-аси у ассертах:**  
      Вбудовані ассерт-функції Cypress надають імпліцитний механізм повтору. Наприклад, при `.should('be.visible')` Cypress перевіряє наявність елементу до завершення дефолтного таймауту.  
      **Приклад:**
      ```javascript
      // Cypress буде повторювати перевірку, поки елемент не стане видимим (або 4 сек. не мине)
      cy.get('[data-testid="login-button"]').should('be.visible');
      ```

    - **Плагін cy.waitUntil():**  
      Плагін `cypress-wait-until` надає динамічний механізм очікування, перевіряючи стан до виконання умови, що робить тести більш надійними.
      **Приклад:**
      ```javascript
      // Чекати, доки елемент статусу не містить текст "Ready"
      cy.waitUntil(() => cy.get('[data-testid="status"]').should('contain', 'Ready'), {
        timeout: 10000,  // До 10 секунд очікування
        interval: 500,   // Перевіряти кожні 500 мс
      });
      ```

2. **Зменшення нестабільності за допомогою інтелектуальних селекторів та повторів**
   - **Інтелектуальні селектори:**  
     Використовуйте стабільні селектори типу `data-testid` чи `data-cy`, уникаючи крихких CSS-класів чи позицій.
   - **Retry (повторення спроб):**  
     Налаштуйте повтори у конфігурації Cypress для автоматичного перезапуску фейлових тестів.  
     **Приклад (глобально у cypress.config.js):**
     ```javascript
     retries: {
       runMode: 2,
       openMode: 0,
     }
     ```
   - **Коригування таймаутів:**  
     Збільшуйте дефолтні таймаути для повільних елементів чи сторонніх API.

3. **Управління станом застосунку**

2. **cy.session: Кешування сесій між тестами**
   - **Призначення:**  
     `cy.session` кешує та відновлює стан (наприклад, cookies, localStorage), що дозволяє уникнути повторної підготовки, наприклад, логіну, у кількох тестах.
   - **Приклад використання:**
     ```javascript
     // Кешування стану логіну через cy.session
     cy.session('loginSession', () => {
       cy.visit('/login');
       cy.get('[data-testid="login-username-input"]').type('demoUser');
       cy.get('[data-testid="login-password-input"]').type('demoPass');
       cy.get('[data-testid="login-submit-button"]').click();
       cy.get('[data-testid="login-success-message"]').should('be.visible');
     });
     
     // Далі у тестах сесія відновлюється автоматично
     cy.visit('/dashboard');
     ```
   - **Переваги:**  
     Прискорення виконання тестів за рахунок повторного використання сесії; стабільність стану.

    #### Важливість `cy.session()` для продуктивності

    **Що таке `cy.session()`?**  
    `cy.session()` кешує та відновлює стан сесії (cookies, localStorage, sessionStorage) між тестами. Особливо корисно для мультидоменного тестування та оптимізації продуктивності.

    **Значення для мультидоменного тестування:**

    - **Однакова сесія між доменами:**  
      Коли тести вимагають стану логіну на кількох доменах, `cy.session()` дозволяє зберігати автентифікацію. Наприклад, коли аутентифікація відбувається на одному домені, а користувач переходить на інший, сесію легко кешувати.

    - **Мінімізація налаштувань:**  
      Замість логіну перед кожним тестом, через `cy.session()` можна підготувати сесію один раз і відновлювати у різних тестах. Це особливо корисно, коли логін складний.

    **З точки зору продуктивності:**

    - **Швидше виконання:**  
      Кешування сесійних даних пришвидшує тести, бо повторні логіни не потрібні для кожного тесту.

    - **Стабільність:**  
      Однаковий стан сесії — менше нестабільних тестів через проблеми з логіном чи мережею.

    **Приклад використання `cy.session()` у мультидоменному сценарії:**

    ```javascript
    describe('Dashboard Tests with Session Management', () => {
      // Кешування та відновлення процесу логіну, включаючи мультидомен
      beforeEach(() => {
        cy.session('loginSession', () => {
          // Перехід на головну сторінку логіну
          cy.visit('/login');
          cy.get('[data-testid="login-with-oauth"]').click();

          // Використання cy.origin для зовнішньої автентифікації
          cy.origin('https://auth.example.com', () => {
            cy.get('[data-testid="auth-username"]').type('externalUser');
            cy.get('[data-testid="auth-password"]').type('externalPass');
            cy.get('[data-testid="auth-submit"]').click();
          });

          // Перевірка, що після автентифікації нас переносить на дашборд
          cy.url().should('include', '/dashboard');
          cy.get('[data-testid="welcome-message"]').should('contain', 'Welcome');
        });
      });

      it('should display dashboard elements using cached session', () => {
        cy.session('loginSession'); // Відновлення сесії
        cy.visit('/dashboard');
        cy.get('[data-testid="dashboard-title"]').should('be.visible');
      });
    });
    ```
   - **cy.session():**  
     Використовуйте `cy.session()`, щоб кешувати логін-сесії чи інші повторювані сценарії ініціалізації. Це зменшує дублювання та гарантує однаковість між тестами.
     ```javascript
     cy.session('userSession', () => {
       cy.visit('/login');
       cy.login('demoUser', 'demoPass');
       cy.get('[data-testid="login-success-message"]').should('be.visible');
     });
     ```
   - **Кастомні команди:**  
     Виносьте складні дії у кастомні команди, централізуючи логіку керування станом.
     ```javascript
     Cypress.Commands.add('login', (username, password) => {
       cy.get('[data-testid="login-username-input"]').clear().type(username);
       cy.get('[data-testid="login-password-input"]').clear().type(password);
       cy.get('[data-testid="login-submit-button"]').click();
     });
     ```

4. **Робота зі складними інтеракціями користувача**
   - **cy.origin():**  
     Для крос-доменних інтеракцій використовуйте `cy.origin()` для перемикання контексту.  
     **Приклад:**
     ```javascript
     cy.origin('https://external.example.com', () => {
       cy.get('[data-testid="external-element"]').should('be.visible');
     });
     ```

---

#### **C. Найкращі практики**

1. **Пишіть підтримувані й масштабовані тести**
   - Використовуйте модульну структуру тестів (наприклад, вкладені describe-блоки).
   - Максимально робіть тести незалежними й без стану.
   - Групуйте схожі тести у контексти, використовуйте кастомні команди для спільних дій.

2. **Організовуйте код для читабельності та переосмислення**
   - Відділяйте тестову логіку від допоміжних функцій.
   - Використовуйте змістовні імена для тестів, контекстів і кастомних команд.
   - Підтримуйте чітку структуру папок для тестів, кастомних команд і фікстур.

3. **Використовуйте можливості Cypress**
   - Використовуйте вбудовані Cypress механізми повторності та затримки для роботи з динамічним контентом.
   - Підключайте плагіни Cypress (наприклад, cypress-wait-until, cypress-drag-drop, cypress-axe тощо) для спеціалізованих потреб тестування.
   - Коректно налаштовуйте глобальні параметри (baseUrl, timeouts, retries) для підвищення стабільності.

---

#### **D. Кейс-стаді та приклади з практики**

1. **Робота з динамічним контентом:**
   - **Ситуація:**  
     Сторінка завантажує список після API-запиту.
   - **Рішення:**  
     Використовуйте розумні ассерти для очікування рендеру списку й повторів, якщо потрібно.
   - **Приклад:**
     ```javascript
     cy.get('[data-testid="item-list"]').should('be.visible');
     ```

2. **Нестабільний тест через повільну мережу:**
   - **Ситуація:**  
     API-метод іноді виконується повільніше, ніж очікується.
   - **Рішення:**  
     Збільшіть таймаут для цієї команди або використайте кастомне очікування.
   - **Приклад:**
     ```javascript
     cy.get('[data-testid="status"]').should('contain', 'Loaded', { timeout: 10000 });
     ```

3. **Складна інтеракція (мультидоменний логін):**
   - **Ситуація:**  
     Користувач логіниться на одному домені й перенаправляється на інший.
   - **Рішення:**  
     Застосуйте `cy.origin()` для зміни доменного контексту й `cy.session()` для зберігання стану автентифікації.
   - **Приклад:**
     ```javascript
     cy.session('loginSession', () => {
       cy.visit('/login');
       cy.login('demoUser', 'demoPass');
       cy.get('[data-testid="login-success-message"]').should('be.visible');
     });
     
     cy.origin('https://external.example.com', () => {
       cy.visit('/external-dashboard');
       cy.get('[data-testid="external-dashboard"]').should('be.visible');
     });
     ```

---

#### **E. Практичні завдання**

1. **Аналіз і виправлення проблем у персональних проєктах студентів:**
   - Відкрите обговорення для демонстрації та вирішення проблем на прикладі проєктів студентів.

---

#### **F. Додаткові матеріали**

- **Документація Cypress Best Practices:**  
  [Cypress Best Practices](https://docs.cypress.io/guides/references/best-practices)
- **Кейс-стаді з прикладами:**  
  Шукайте блоги та репозиторії на GitHub з описом вирішення проблем динамічного контенту й нестабільних тестів.

---

### **Реальні проблеми у Cypress-тестуванні**

**1. Нестабільні тести через асинхронність:**

- **Проблема:**  
  Тести інколи падають, бо елементи з’являються або змінюють стан у непередбачуваний час через мережу чи оновлення контенту.
- **Рішення:**  
  Використовуйте імпліцитне очікування в ассертах (наприклад, `.should('be.visible')`) чи `cy.waitUntil()` для динамічного очікування настання умови, а не фіксованих затримок.

**2. Умови гонки (Race Conditions):**

- **Проблема:**  
  Коли виконується кілька асинхронних дій (наприклад, кілька API-запитів), тести можуть перевіряти стан до завершення всіх дій.
- **Рішення:**  
  Використовуйте `cy.intercept()` для очікування відповіді API (`cy.wait('@alias')`) і виконуйте ассерт після завершення дій.

**3. Проблеми з вибором елементів:**

- **Проблема:**  
  Динамічні застосунки можуть змінювати ідентифікатори елементів, тож тести "ламаються", якщо селектори базуються на CSS-класах або позиціях.
- **Рішення:**  
  Використовуйте стабільні спеціальні селектори, наприклад, атрибути `data-testid` або `data-cy`, які рідше змінюються.

**4. Управління сесійним станом:**

- **Проблема:**  
  Тести, які залежать від стану застосунку (наприклад, коли користувач залогінений), можуть падати, якщо стан не оновлюється або не ділиться між тестами.
- **Рішення:**  
  Використовуйте `cy.session()` для кешування/відновлення сесійних даних і гарантії консистентного початкового стану.

**5. Робота з кількома доменами:**

- **Проблема:**  
  Тестування застосунків з кількома доменами часто наштовхується на політику same-origin.
- **Рішення:**  
  Використовуйте `cy.origin()` для безпечної взаємодії з елементами на зовнішніх доменах.

**6. Варіабельність середовища:**

- **Проблема:**  
  Відмінності між локальним, staging і production середовищем призводять до різної поведінки тестів.
- **Рішення:**  
  Використовуйте змінні оточення (налаштовані у `.env` і завантажені через префікс `VITE_`), щоб керувати baseUrl, логінами та API endpoint. Це робить тести адаптивними.

**7. Мережеві нестабільності:**

- **Проблема:**  
  Непередбачувана відповідь мережі викликає нестабільність тестів, що залежать від API.
- **Рішення:**  
  Використовуйте `cy.intercept()` для підміни відповідей мережі, забезпечуючи стабільні дані для тестів та зменшуючи залежність від зовнішніх систем.

---

### **Потенційні питання студентів та відповіді**

1. **Q:** *Чому тести нестабільні та як це виправити?*  
   **A:** Тести можуть бути нестабільними через асинхронний контент, затримки мережі або динамічні елементи. Зменшіть нестабільність через розумні ассерти, відповідний час очікування, повтори та стабільні селектори. Використовуйте такі плагіни, як `cypress-wait-until` для роботи з динамікою.

2. **Q:** *Яке значення має cy.origin() для мультидоменного тестування?*  
   **A:** `cy.origin()` дає можливість виконувати команди на іншому домені, ніж основна програма, дозволяючи тестувати сценарії із перетином доменів (наприклад, сторонній логін або зовнішній контент) без порушення політики same-origin.

3. **Q:** *Як cy.session() підвищує продуктивність тестів у мультидоменних сценаріях?*  
   **A:** `cy.session()` кешує й відновлює дані сесії (cookies, localStorage), скорочуючи потребу у повторних логінах чи налаштуванні перед кожним тестом. Це пришвидшує й стабілізує тести, особливо при сценаріях з кількома доменами.

4. **Q:** *Які найкращі практики організації тестів для уникнення нестабільності?*  
   **A:** Пишіть модульні тести з вкладеними describe-блоками, використовуйте стабільні селектори (`data-testid`), налаштовуйте таймаути по ситуації та користуйтеся повтореннями. Ізолюйте й розділяйте тести для мінімізації впливу одного тесту на інший.

5. **Q:** *Яку роль грають плагіни у вирішенні реальних проблем Cypress?*  
   **A:** Плагіни надають можливості (розширене очікування, перевірка доступності, покращені логування), які допомагають впоратися зі складним контентом та нестабільними тестами. Вони зменшують обсяг повторюваного коду і підвищують надійність.

6. **Q:** *Як вирішити, коли використовувати cy.wait(), а коли розумні стратегії типу cy.waitUntil()?*  
   **A:** Використовуйте `cy.wait()` лише для фіксованих затримок у прогнозованих сценаріях. Для роботи з динамікою краще `cy.waitUntil()` або ланцюжок ассертів із вбудованим повтором, щоб чекати появи умови без зайвої затримки тесту.
