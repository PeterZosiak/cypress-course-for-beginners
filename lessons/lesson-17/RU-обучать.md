## **Урок 17: Проблемы и решения с Cypress в реальном мире – Примеры из практики**

### **Цели**

- Определять распространённые сложности при использовании Cypress для end-to-end тестирования в реальных приложениях.
- Предлагать практические решения и стратегии для работы с динамическим контентом, асинхронным поведением, нестабильными тестами и сложными взаимодействиями.
- Делиться лучшими практиками написания поддерживаемых, масштабируемых и надёжных тестов.
- Представлять кейсы и примеры из реальных проектов, а также проводить практические задания по отладке и рефакторингу проблемных тестов.

---

### **Структура содержания**

#### **A. Типичные проблемы с Cypress**

1. **Работа с динамическим контентом и асинхронным поведением**
   - **Проблема:**  
     Многие веб-приложения обновляют интерфейс динамически, из-за чего элементы могут быть недоступны в момент, когда тест их ожидает.
   - **Сложности:**  
     - Ожидание появления элементов.
     - Убеждаться, что асинхронные вызовы API и анимации завершились до проверок.
     - Работа с непоследовательными состояниями элементов.

2. **Борьба с "флапающими" тестами и обеспечение надёжности тестов**
   - **Проблема:**  
     "Флапающие" тесты иногда проходят, а иногда нет даже без изменений кода — часто из-за таймингов, сетевых задержек или нестабильных селекторов.
   - **Сложности:**  
     - Неоднозначное время рендера элементов.
     - Временные проблемы с сетью.
     - Отличия окружений: локальная среда vs. CI.

3. **Тестирование сложных пользовательских взаимодействий и приложений со множеством состояний**
   - **Проблема:**  
     Приложения с комплексными рабочими процессами, множественными состояниями или вложенными компонентами сложно тестировать надёжно.
   - **Сложности:**  
     - Эмуляция многошаговых пользовательских действий (например, drag-and-drop, вложенные модальные окна).
     - Сохранение состояния приложения между тестами.
     - Взаимодействия, зависящие от данных из разных источников или от ответов API.

---

#### **B. Практические решения и стратегии**

1. **Эффективные стратегии ожидания**
   - **cy.wait():**  
     Используйте `cy.wait()` для паузы на фиксированное время, если это необходимо.  
     **Пример:**  
     ```javascript
     cy.wait(1000); // Подождать 1 секунду
     ```
   - **Умные проверки:**  
     Задействуйте автоматический механизм повторных попыток Cypress через проверки наличия элементов или их состояния.  
     **Пример:**  
     ```javascript
     cy.get('[data-testid="dynamic-element"]').should('be.visible');
     ```
   - **Пользовательские ожидания с cy.waitUntil:**  
     Используйте плагин `cypress-wait-until`, чтобы явно ждать выполнения условия.  
     **Пример:**  
     ```javascript
     cy.waitUntil(() => cy.get('[data-testid="status"]').should('contain', 'Ready'));
     ```

   - **Почему стоит избегать явных `cy.wait()`**
    **1. Хрупкость и непредсказуемость тестов:**
    - **Фиксированные задержки произвольны:**  
      Ожидание фиксированной продолжительности (например, `cy.wait(2000)`) подразумевает, что приложение всегда будет готово через это время. В реальных условиях, из-за сетевой задержки, времени ответа сервера или клиентского рендера, это может быть не так. В итоге тесты то проходят, то нет — становятся флапающими.
    - **Потеря времени:**  
      Фиксированные ожидания продлевают выполнение теста даже если приложение уже готово. Если элемент загрузился за 500 мс, а вы ждёте 2000 мс — теряется время.

    **2. Лучшие альтернативы:**
    - **Таймауты в проверках:**  
      Встроенные проверки `.should()` в Cypress включают механизм повторных попыток. При проверке видимости элемента Cypress повторит попытки до появления элемента или до истечения таймаута.  
      **Пример:**
      ```javascript
      // Cypress будет повторять проверку до появления элемента, либо до истечения 4 секунд (по умолчанию)
      cy.get('[data-testid="login-button"]').should('be.visible');
      ```

    - **Плагин cy.waitUntil():**  
      Плагин `cypress-wait-until` предлагает динамический механизм ожидания — условие проверяется до наступления события. Это исключает произвольные задержки и делает тесты надёжнее.
      **Пример:**
      ```javascript
      // Ждём, пока элемент статуса не получит текст "Ready"
      cy.waitUntil(() => cy.get('[data-testid="status"]').should('contain', 'Ready'), {
        timeout: 10000,  // Ждать до 10 секунд
        interval: 500,   // Проверять каждые 500 мс
      });
      ```

2. **Снижение флак-эффекта с помощью умных селекторов и ретраев**
   - **Умные селекторы:**  
     Используйте стабильные селекторы типа `data-testid` или `data-cy`, избегая CSS-классов или позиций элементов.
   - **Ретраи (повторы):**  
     Настройте повторные прогоны флапающих тестов в конфиге Cypress.  
     **Пример (глобально в cypress.config.js):**
     ```javascript
     retries: {
       runMode: 2,
       openMode: 0,
     }
     ```
   - **Настройка таймаутов:**  
     Увеличивайте значения по умолчанию при работе с медленными элементами или внешними API.

3. **Управление состоянием приложения**

2. **cy.session: Управление сессиями между тестами**
   - **Назначение:**  
     `cy.session` кеширует и восстанавливает состояние (например, cookies, localStorage), что избавляет от повторной подготовки окружения (например, логина) во множестве тестов.
   - **Пример использования:**
     ```javascript
     // Пример: Используем cy.session для кеширования состояния входа
     cy.session('loginSession', () => {
       cy.visit('/login');
       cy.get('[data-testid="login-username-input"]').type('demoUser');
       cy.get('[data-testid="login-password-input"]').type('demoPass');
       cy.get('[data-testid="login-submit-button"]').click();
       cy.get('[data-testid="login-success-message"]').should('be.visible');
     });
     
     // В последующих тестах сессия восстановится автоматически
     cy.visit('/dashboard');
     ```
   - **Преимущества:**  
     Ускоряет тесты за счёт отсутствия повторных логинов; обеспечивает единое состояние.

    #### Важность `cy.session()` с точки зрения производительности

    **Что такое `cy.session()`?**  
    `cy.session()` кеширует и восстанавливает состояние сессии (например, cookies, localStorage, sessionStorage) между тестами. Особенно полезно для мультидоменного тестирования и оптимизации производительности.

    **Важность для мультидоменного тестирования:**

    - **Единая сессия между доменами:**  
      Если тестам нужна сессия на нескольких доменах (например, аутентификация происходит на одном домене, а пользователь редиректится на другой), `cy.session()` помогает сохранить авторизацию. Это упрощает подготовку окружения.

    - **Снижение накладных расходов:**  
      Вместо логина перед каждым тестом, с `cy.session()` достаточно залогиниться один раз, а затем сессия переиспользуется. Особенно полезно для комплексных сценариев с разными доменами.

    **С точки зрения производительности:**

    - **Быстрее выполнение тестов:**  
      Благодаря кешу сессий не требуются лишние повторения логина или подготовки данных, сокращается общее время прогонов.
    - **Стабильность:**  
      Согласованность сессий между тестами снижает количество флапающих тестов из-за неустойчивых процедур логина или сетевых задержек.

    **Пример использования `cy.session()` для мультидоменного сценария:**

    ```javascript
    describe('Dashboard Tests with Session Management', () => {
      // Создаём сессию, кеширующую логин с мультидоменным переходом.
      beforeEach(() => {
        cy.session('loginSession', () => {
          // Посетить страницу логина приложения
          cy.visit('/login');
          cy.get('[data-testid="login-with-oauth"]').click();

          // Используем cy.origin для внешней аутентификации
          cy.origin('https://auth.example.com', () => {
            cy.get('[data-testid="auth-username"]').type('externalUser');
            cy.get('[data-testid="auth-password"]').type('externalPass');
            cy.get('[data-testid="auth-submit"]').click();
          });

          // Проверяем, что попали на дашборд после авторизации
          cy.url().should('include', '/dashboard');
          cy.get('[data-testid="welcome-message"]').should('contain', 'Welcome');
        });
      });

      it('should display dashboard elements using cached session', () => {
        cy.session('loginSession'); // Восстановить сессию
        cy.visit('/dashboard');
        cy.get('[data-testid="dashboard-title"]').should('be.visible');
      });
    });
    ```
   - **cy.session():**  
     Используйте `cy.session()` для кеширования логин-сессий или других повторяющихся шагов подготовки. Это уменьшает лишние операции и повышает согласованность между тестами.
     ```javascript
     cy.session('userSession', () => {
       cy.visit('/login');
       cy.login('demoUser', 'demoPass');
       cy.get('[data-testid="login-success-message"]').should('be.visible');
     });
     ```
   - **Пользовательские команды:**  
     Выносите сложные взаимодействия в кастомные команды — это централизует управление логикой изменения состояния.
     ```javascript
     Cypress.Commands.add('login', (username, password) => {
       cy.get('[data-testid="login-username-input"]').clear().type(username);
       cy.get('[data-testid="login-password-input"]').clear().type(password);
       cy.get('[data-testid="login-submit-button"]').click();
     });
     ```

4. **Работа со сложными пользовательскими взаимодействиями**
   - **cy.origin():**  
     Для мультидоменных или кросс-доменных взаимодействий используйте `cy.origin()` для переключения контекста.  
     **Пример:**
     ```javascript
     cy.origin('https://external.example.com', () => {
       cy.get('[data-testid="external-element"]').should('be.visible');
     });
     ```

---

#### **C. Лучшие практики**

1. **Пишите поддерживаемые и масштабируемые тесты**
   - Используйте модульную структуру тестов (например, вложенные describe-блоки).
   - Старайтесь делать тесты независимыми и статeless по возможности.
   - Группируйте похожие тесты по контекстам и используйте кастомные команды для общих действий.

2. **Организуйте код тестов для читаемости и повторного использования**
   - Разделяйте тестовую логику и вспомогательные функции.
   - Даём осмысленные имена тестам, контекстам, кастом-командам.
   - Поддерживайте понятную структуру директорий для файлов тестов, кастомных команд и фикстур.

3. **Используйте возможности Cypress**
   - Используйте встроенные повторные проверки и механизмы ожидания Cypress для работы с динамическим контентом.
   - Применяйте плагины Cypress (например, cypress-wait-until, cypress-drag-drop, cypress-axe и т.д.) для решения специфических задач.
   - Глобально конфигурируйте параметры (например, baseUrl, таймауты, retries) для повышения стабильности тестов.

---

#### **D. Кейсы и примеры из практики**

1. **Работа с динамическим контентом:**
   - **Сценарий:**  
     Страница загружает список объектов после вызова API.
   - **Решение:**  
     Использовать умные проверки, чтобы дождаться появления списка, а при необходимости использовать повторные попытки.
   - **Пример:**
     ```javascript
     cy.get('[data-testid="item-list"]').should('be.visible');
     ```

2. **"Флапающий" тест из-за медленной сети:**
   - **Сценарий:**  
     Вызов API иногда занимает больше времени чем обычно.
   - **Решение:**  
     Увеличить таймаут для конкретной команды или применить пользовательскую функцию ожидания.
   - **Пример:**
     ```javascript
     cy.get('[data-testid="status"]').should('contain', 'Loaded', { timeout: 10000 });
     ```

3. **Сложное взаимодействие (логин через несколько доменов):**
   - **Сценарий:**  
     Пользователь авторизуется на одном домене и перенаправляется на другой.
   - **Решение:**  
     Использовать `cy.origin()` для перехода между доменами и `cy.session()` для сохранения состояния авторизации.
   - **Пример:**
     ```javascript
     cy.session('loginSession', () => {
       cy.visit('/login');
       cy.login('demoUser', 'demoPass');
       cy.get('[data-testid="login-success-message"]').should('be.visible');
     });
     
     cy.origin('https://external.example.com', () => {
       cy.visit('/external-dashboard');
       cy.get('[data-testid="external-dashboard"]').should('be.visible');
     });
     ```

---

#### **E. Практическая работа**

1. **Анализ и отладка проблем в личных проектах студентов:**
   - Открытое обсуждение — показ и решение затруднений на примере проектов студентов.

---

#### **F. Дополнительные ресурсы**

- **Документация Cypress по лучшим практикам:**  
  [Cypress Best Practices](https://docs.cypress.io/guides/references/best-practices)
- **Примеры из кейсов:**  
  Изучайте блоги и GitHub‑репозитории сообществ, в которых команды делятся тем, как они решали проблемы с "флапающими" тестами и динамическим контентом.

---

### **Проблемы Cypress тестирования в реальном мире**

**1. "Флапающие" тесты из-за асинхронного поведения:**

- **Проблема:**  
  Тесты иногда падают, потому что элементы появляются или меняют состояние непредсказуемо — из-за сетевых задержек или обновления динамического контента.
- **Решение:**  
  Используйте неявные ожидания с проверками (например, `.should('be.visible')`) или `cy.waitUntil()`, чтобы динамически ожидать условия, а не полагаться на фиксированные задержки.

**2. Гонки (Race Conditions):**

- **Проблема:**  
  Если идут несколько асинхронных действий (например, параллельные вызовы API), тесты могут начинать проверки до завершения всех операций.
- **Решение:**  
  Используйте `cy.intercept()` для ожидания ответов API (`cy.wait('@alias')`) и стройте проверки после завершения всех нужных действий.

**3. Проблемы выбора элементов:**

- **Проблема:**  
  Динамические приложения могут менять идентификаторы элементов, что приводит к сбоям при использовании селекторов по CSS-классам или позициям.
- **Решение:**  
  Используйте стабильные специальные селекторы — атрибуты `data-testid` или `data-cy`, которые меняются редко.

**4. Управление сессиями и состоянием:**

- **Проблема:**  
  Тесты, зависящие от состояния приложения (например, залогиненный пользователь), могут падать, если состояние не сбрасывается или не передаётся между тестами.
- **Решение:**  
  Применяйте `cy.session()` для кеширования и восстановления сессий, обеспечивая единое начальное состояние для каждого теста.

**5. Работа с несколькими доменами:**

- **Проблема:**  
  При тестировании приложений, работающих на нескольких доменах, возникают проблемы с политикой одинакового происхождения (same-origin).
- **Решение:**  
  Используйте `cy.origin()` для безопасного взаимодействия с элементами внешних доменов без нарушения политики same-origin.

**6. Переменные окружения:**

- **Проблема:**  
  Отличия между локальной, стейджинг и продакшен средами могут приводить к нестабильности тестов.
- **Решение:**  
  Задайте переменные окружения (через `.env` файлы и префикс `VITE_`), чтобы управлять настройками вроде `baseUrl`, учётных данных и API‑эндпоинтов. Это делает тесты гибкими для разных сред.

**7. Нестабильность сети:**

- **Проблема:**  
  Непредсказуемые сетевые ответы могут приводить к флапающим тестам, зависящим от API.
- **Решение:**  
  Используйте `cy.intercept()` для подмены сетевых ответов, обеспечивая согласованные данные для тестов и снижая зависимость от внешних систем.

---

### **Возможные вопросы студентов и ответы**

1. **Q:** *Почему тесты флапают, и как этого избежать?*  
   **A:** Флап происходит из-за асинхронного контента, сетевых задержек или динамических элементов. Минимизировать его можно с помощью умных проверок, правильных ожиданий, ретраев, стабильных селекторов. Помогают такие плагины, как `cypress-wait-until` для работы с динамикой.

2. **Q:** *Зачем использовать cy.origin() в мультидоменном тестировании?*  
   **A:** `cy.origin()` позволяет выполнять команды на другом домене, чем основной, чтобы тестировать сквозные сценарии (например, логин через сторонние сервисы или работу с внешним контентом), не нарушая политики same-origin.

3. **Q:** *Как cy.session() ускоряет тестирование в мультидоменных сценариях?*  
   **A:** `cy.session()` кеширует и восстанавливает данные сессии (cookies, localStorage), благодаря чему не нужно каждый раз логиниться или повторять подготовительные шаги. Тесты идут быстрее и стабильнее, особенно если нужно работать через разные домены.

4. **Q:** *Как лучше структурировать тесты, чтобы избежать фапа?*  
   **A:** Пишите модульные тесты через вложенные describe-блоки, используйте стабильные селекторы (data-testid), задавайте корректные таймауты и ретраи. Изоляция и независимость тестов снимают пересечения между ними.

5. **Q:** *Какую роль играют плагины при решении реальных проблем Cypress?*  
   **A:** Плагины добавляют возможности (например, расширенное ожидание, проверки доступности, улучшенное логирование), которые помогают справляться с динамическим контентом, флапом, сокращают количество шаблонного кода и делают тесты надёжнее.

6. **Q:** *Когда использовать cy.wait(), а когда более умные решения, как cy.waitUntil()?*  
   **A:** `cy.wait()` используйте для фиксированных задержек в предсказуемых сценариях. Для динамики и асинхронного поведения предпочтительнее `cy.waitUntil()` или цепочки проверок с ретраями, которые не замедляют тесты без необходимости.